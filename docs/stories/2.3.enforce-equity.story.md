# Story 2.3: Implémenter l'Enforcement de l'Équité Stricte

## Status

**Draft**

---

## Story

**As a** organisateur d'événement,
**I want** que tous les participants aient une expérience équitable avec un écart de rencontres uniques ≤1,
**so that** personne ne se sente désavantagé lors de l'événement.

---

## Acceptance Criteria

1. Une fonction `enforce_equity(planning: Planning, config: PlanningConfig) -> Planning` dans `src/optimizer.py`
2. La fonction calcule les rencontres uniques par participant via `compute_metrics`
3. Si `max_unique - min_unique <= 1`, le planning est retourné inchangé
4. Sinon, la fonction identifie participants sur-exposés (> moyenne) et sous-exposés (< moyenne)
5. Des swaps ciblés sont effectués pour réduire l'écart tout en minimisant l'impact sur les répétitions
6. La fonction garantit que le planning final respecte FR6 (équité ±1)
7. Les tests vérifient :
   - Planning déjà équitable → inchangé
   - Planning déséquilibré (écart 3) → ramené à écart ≤1
   - Métriques finales confirment `max_unique - min_unique <= 1`
   - Performance : enforcement pour N=300 en <2s
8. Un message de logging INFO indique : "Équité atteinte : écart de X rencontres entre min et max"

---

## Tasks / Subtasks

- [ ] **Task 1: Implémenter enforce_equity() - signature et docstring** (AC: 1, 8)
  - [ ] Créer fonction dans `src/optimizer.py`:
    ```python
    def enforce_equity(planning: Planning, config: PlanningConfig) -> Planning
    ```
  - [ ] Docstring Google style:
    - Description: "Garantit l'équité stricte ±1 rencontres uniques entre participants (Phase 3)"
    - Stratégie: calcul métriques, détection écart, swaps ciblés sur-exposés ↔ sous-exposés
    - Args avec types
    - Returns: "Planning avec garantie max_unique - min_unique ≤ 1"
    - Complexity: O(S × N) - post-traitement léger
    - Guarantees: FR6 toujours respectée en sortie

- [ ] **Task 2: Implémenter calcul métriques et détection écart** (AC: 2, 3)
  - [ ] Calculer métriques initiales:
    ```python
    from src.metrics import compute_metrics
    metrics = compute_metrics(planning, config)
    ```
  - [ ] Vérifier écart actuel:
    ```python
    if metrics.equity_gap <= 1:
        logger.info(f"Équité déjà atteinte : écart de {metrics.equity_gap}")
        return planning
    ```
  - [ ] Logger situation:
    ```python
    logger.info(f"Enforcement équité : écart actuel {metrics.equity_gap}, "
                f"min={metrics.min_unique}, max={metrics.max_unique}")
    ```

- [ ] **Task 3: Identifier participants sur-exposés et sous-exposés** (AC: 4)
  - [ ] Calculer moyenne rencontres:
    ```python
    mean_unique = metrics.mean_unique
    ```
  - [ ] Créer listes:
    ```python
    over_exposed = []  # Participants avec unique_meetings > mean
    under_exposed = []  # Participants avec unique_meetings < mean
    for p_id, unique_count in enumerate(metrics.unique_meetings_per_person):
        if unique_count > mean_unique:
            over_exposed.append((p_id, unique_count))
        elif unique_count < mean_unique:
            under_exposed.append((p_id, unique_count))
    ```
  - [ ] Trier par écart à la moyenne (priorité participants extrêmes)

- [ ] **Task 4: Implémenter stratégie swaps ciblés** (AC: 5, 6)
  - [ ] Stratégie MVP simplifiée:
    - Parcourir sessions
    - Pour chaque session, chercher paires (over, under) dans tables différentes
    - Si swap (over ↔ under) réduit écart sans trop augmenter répétitions: appliquer
    - Répéter jusqu'à equity_gap ≤ 1
  - [ ] Pseudocode:
    ```python
    while metrics.equity_gap > 1:
        swap_found = False
        for session in planning.sessions:
            for t1_id, table1 in enumerate(session.tables):
                for t2_id, table2 in enumerate(session.tables):
                    if t1_id >= t2_id:
                        continue
                    # Chercher over_exposed dans table1, under_exposed dans table2
                    for p_over in over_exposed_ids:
                        for p_under in under_exposed_ids:
                            if p_over in table1 and p_under in table2:
                                # Évaluer impact swap sur équité
                                # Si améliore équité: appliquer
                                # swap_found = True
                                break
        if not swap_found:
            break  # Sécurité anti-boucle infinie
        metrics = compute_metrics(planning, config)
    ```

- [ ] **Task 5: Implémenter logging Phase 3** (AC: 8)
  - [ ] Message final:
    ```python
    final_metrics = compute_metrics(planning, config)
    logger.info(f"Équité atteinte : écart de {final_metrics.equity_gap} rencontres "
                f"entre min ({final_metrics.min_unique}) et max ({final_metrics.max_unique})")
    ```
  - [ ] Si échec atteindre équité (sécurité):
    ```python
    if final_metrics.equity_gap > 1:
        logger.warning(f"Équité non atteinte : écart {final_metrics.equity_gap}. "
                      f"Configuration difficile, meilleur effort appliqué.")
    ```

- [ ] **Task 6: Créer tests test_optimizer.py pour enforce_equity** (AC: 7)
  - [ ] Compléter `tests/test_optimizer.py` avec tests enforcement équité
  - [ ] Fonction helper: `create_unbalanced_planning()` pour plannings déséquilibrés

- [ ] **Task 7: Test planning déjà équitable → inchangé** (AC: 3, 7)
  - [ ] Créer planning avec écart ≤1:
    - Utiliser generate_baseline + improve_planning si produit écart ≤1
    - Ou construire manuellement planning équilibré
  - [ ] Copier state initial
  - [ ] Appliquer enforce_equity
  - [ ] Vérifier planning inchangé (même tables)
  - [ ] Vérifier log contient "Équité déjà atteinte"

- [ ] **Task 8: Test planning déséquilibré (écart 3) → écart ≤1** (AC: 7)
  - [ ] Créer planning manuellement avec écart = 3:
    - Forcer participant 0 à rencontrer beaucoup de monde
    - Forcer participant 5 à rencontrer peu de monde
  - [ ] Calculer metrics_before
  - [ ] Appliquer enforce_equity
  - [ ] Calculer metrics_after
  - [ ] Vérifier: `metrics_after.equity_gap <= 1`
  - [ ] Vérifier: écart réduit par rapport à before

- [ ] **Task 9: Test métriques finales confirment équité** (AC: 7)
  - [ ] Pour plusieurs configs (N=30, N=50, N=100):
    - Générer baseline
    - Améliorer (improve_planning)
    - Enforcer équité (enforce_equity)
    - Calculer métriques finales
    - Assert: `metrics.equity_gap <= 1`
    - Assert: tous participants dans [min_unique, min_unique+1]

- [ ] **Task 10: Test performance N=300 <2s** (AC: 7)
  - [ ] Marquer test avec `@pytest.mark.slow`
  - [ ] Config: N=300, X=60, x=5, S=15
  - [ ] Générer baseline + améliorer
  - [ ] Mesurer temps enforce_equity uniquement:
    ```python
    start = time.time()
    equitable = enforce_equity(improved, config)
    elapsed = time.time() - start
    ```
  - [ ] Assert: `elapsed < 2.0` secondes
  - [ ] Vérifier équité finale: `equity_gap <= 1`

- [ ] **Task 11: Test planning valide après enforcement**
  - [ ] Vérifier invariants post-enforcement:
    - Tous participants présents chaque session
    - Aucun participant dupliqué
    - Tailles tables écart ≤1 (FR7)
    - Total participants = N

- [ ] **Task 12: Test cas limite équité impossible** (sécurité)
  - [ ] Configuration mathématiquement difficile
  - [ ] Si équité non atteignable en temps raisonnable:
    - Vérifier fonction s'arrête (pas boucle infinie)
    - Vérifier WARNING loggé
    - Accepter écart > 1 dans ce cas (best effort)

- [ ] **Task 13: Valider couverture et qualité**
  - [ ] `pytest tests/test_optimizer.py::test_enforce_equity -v`
  - [ ] `pytest tests/test_optimizer.py --cov=src.optimizer --cov-report=term`
  - [ ] Vérifier couverture ≥90% globale optimizer.py
  - [ ] `mypy src/optimizer.py --strict`
  - [ ] `black` et `ruff` passent

- [ ] **Task 14: Créer QA Gate YAML**
  - [ ] Créer `docs/qa/gates/2.3-enforce-equity.yml`
  - [ ] Checks: pytest (fast + slow), mypy, black, ruff, coverage ≥90%

---

## Dev Notes

### Dépendance sur Stories Précédentes

**Stories 2.1-2.2 et Epic 1 doivent être complétées** :
- Epic 1: Models, baseline, metrics
- 2.1: evaluate_swap()
- 2.2: improve_planning()

Cette story implémente **Phase 3 du pipeline** (enforcement équité FR6).

### Implémentation Exacte - enforce_equity()

[Source: docs/architecture/interfaces-entre-modules.md#3.5]

```python
import logging
from src.models import Planning, PlanningConfig
from src.metrics import compute_metrics

logger = logging.getLogger(__name__)


def enforce_equity(planning: Planning, config: PlanningConfig) -> Planning:
    """
    Garantit l'équité stricte ±1 rencontres uniques entre participants (Phase 3).

    Stratégie:
    - Calculer métriques actuelles
    - Si écart ≤1, retourner inchangé
    - Sinon, identifier participants sur-exposés et sous-exposés
    - Swaps ciblés pour réduire écart (priorité équité > répétitions)

    Args:
        planning (Planning): Planning amélioré (post Phase 2)
        config (PlanningConfig): Configuration

    Returns:
        Planning: Planning avec garantie max_unique - min_unique ≤ 1

    Guarantees:
        - FR6 toujours respectée (equity_gap ≤ 1)
        - Planning valide (tous participants assignés)
        - Impact minimal sur répétitions

    Complexity:
        O(S × N) - post-traitement léger

    Performance:
        N=300: <2s

    Examples:
        >>> improved = improve_planning(baseline, config)
        >>> equitable = enforce_equity(improved, config)
        >>> metrics = compute_metrics(equitable, config)
        >>> assert metrics.equity_gap <= 1  # FR6 garantie
    """
    metrics = compute_metrics(planning, config)

    if metrics.equity_gap <= 1:
        logger.info(f"Équité déjà atteinte : écart de {metrics.equity_gap}")
        return planning

    logger.info(f"Enforcement équité : écart actuel {metrics.equity_gap}, "
                f"min={metrics.min_unique}, max={metrics.max_unique}")

    # Stratégie simplifiée MVP : swaps ciblés entre over-exposed et under-exposed
    # Implémentation détaillée selon besoin (peut nécessiter plusieurs passes)
    # Pour MVP, on accepte que cette phase soit best-effort avec garantie finale

    # [Logique de swaps ciblés - implémentation détaillée en dev]
    # Pseudocode:
    # - Identifier participants avec unique_meetings < moyenne
    # - Identifier participants avec unique_meetings > moyenne
    # - Effectuer swaps préférant paires (under, over) pour rééquilibrage
    # - Vérifier écart final ≤1

    # Boucle enforcement (maximum 50 passes pour sécurité)
    max_passes = 50
    for pass_num in range(max_passes):
        # Recalculer métriques
        metrics = compute_metrics(planning, config)

        if metrics.equity_gap <= 1:
            break

        # Identifier over/under exposed
        mean_unique = metrics.mean_unique
        over_exposed = [(p_id, count) for p_id, count in enumerate(metrics.unique_meetings_per_person) if count > mean_unique]
        under_exposed = [(p_id, count) for p_id, count in enumerate(metrics.unique_meetings_per_person) if count < mean_unique]

        # Chercher et appliquer swap bénéfique pour équité
        swap_applied = False
        for session_id, session in enumerate(planning.sessions):
            for t1_id in range(len(session.tables)):
                for t2_id in range(t1_id + 1, len(session.tables)):
                    # Chercher over dans t1, under dans t2 (ou inverse)
                    for p_over, _ in over_exposed:
                        for p_under, _ in under_exposed:
                            if p_over in session.tables[t1_id] and p_under in session.tables[t2_id]:
                                # Swap pour rééquilibrage
                                session.tables[t1_id].remove(p_over)
                                session.tables[t1_id].add(p_under)
                                session.tables[t2_id].remove(p_under)
                                session.tables[t2_id].add(p_over)
                                swap_applied = True
                                break
                        if swap_applied:
                            break
                if swap_applied:
                    break
            if swap_applied:
                break

        if not swap_applied:
            logger.warning(f"Aucun swap bénéfique trouvé à la passe {pass_num + 1}")
            break

    # Métriques finales
    final_metrics = compute_metrics(planning, config)

    if final_metrics.equity_gap <= 1:
        logger.info(f"Équité atteinte : écart de {final_metrics.equity_gap} rencontres "
                    f"entre min ({final_metrics.min_unique}) et max ({final_metrics.max_unique})")
    else:
        logger.warning(f"Équité non atteinte après {max_passes} passes : écart {final_metrics.equity_gap}. "
                      f"Configuration difficile, meilleur effort appliqué.")

    return planning
```

### Comprendre l'Enforcement d'Équité

**Objectif:** Garantir FR6 (écart max-min ≤1)

**Exemple concret:**
- Avant: min=8, max=12 → écart=4 (non équitable)
- Après: min=10, max=11 → écart=1 (équitable ✓)

**Stratégie:**
1. Identifier participants "chanceux" (beaucoup de rencontres uniques) → over_exposed
2. Identifier participants "malchanceux" (peu de rencontres uniques) → under_exposed
3. Échanger positions pour rééquilibrer (participant chanceux va dans table moins favorable)

**Trade-off:**
- Peut augmenter légèrement répétitions
- Priorité équité > minimiser répétitions (FR6 est garantie stricte)

### Algorithme Détaillé

**Étape 1: Calcul métriques et détection**
```python
metrics = compute_metrics(planning, config)
if metrics.equity_gap <= 1:
    return planning  # Déjà équitable
```

**Étape 2: Identification participants**
```python
mean = metrics.mean_unique
over_exposed = [p for p, count in enumerate(...) if count > mean]
under_exposed = [p for p, count in enumerate(...) if count < mean]
```

**Étape 3: Swaps ciblés**
- Parcourir sessions
- Chercher paires (over, under) dans tables différentes
- Swapper pour rapprocher de la moyenne
- Recalculer métriques

**Étape 4: Vérification finale**
```python
final_metrics = compute_metrics(planning, config)
assert final_metrics.equity_gap <= 1  # Garantie FR6
```

### Complexité Algorithmique

**Temps:** O(S × N) en moyenne

Décomposition:
- Calcul métriques: O(S × X × x²) + O(N) = O(S × X × x²)
- Identification over/under: O(N)
- Passes enforcement: O(passes × S × X × N)
  - Nombre passes attendu: 5-10 (empirique)
  - Chaque passe: O(S × X) recherche + O(N) vérifications

**Facteur dominant:** O(S × X × x²) du calcul métriques (réutilise compute_meeting_history)

**Cas pratique:**
- N=300, S=15, X=60, x=5
- Passes: ~10
- Temps: <2s (beaucoup moins que Phase 2)

### Garantie Mathématique FR6

**FR6:** "Le système doit garantir qu'aucun participant ne rencontre moins de (mean - 1) ou plus de (mean + 1) personnes uniques"

**Équivalent:** `max_unique - min_unique ≤ 1`

**Garantie de cette fonction:**
- Boucle while `equity_gap > 1`
- Maximum max_passes (50) pour sécurité
- Si atteint: WARNING loggé, best effort

**Note:** Pour configurations mathématiquement impossibles (très peu de sessions, très petites tables), l'équité stricte peut ne pas être atteignable. La fonction fait best effort et logue WARNING.

### Logging et Traçabilité

**Messages clés:**
```python
# Déjà équitable
logger.info(f"Équité déjà atteinte : écart de {metrics.equity_gap}")

# Début enforcement
logger.info(f"Enforcement équité : écart actuel {metrics.equity_gap}, min={metrics.min_unique}, max={metrics.max_unique}")

# Succès
logger.info(f"Équité atteinte : écart de {final_metrics.equity_gap} rencontres entre min ({final_metrics.min_unique}) et max ({final_metrics.max_unique})")

# Échec (rare)
logger.warning(f"Équité non atteinte après {max_passes} passes : écart {final_metrics.equity_gap}")
```

### Cas Limites et Edge Cases

**1. Planning déjà équitable:**
- Détection immédiate, return inchangé
- Performance optimale (O(S × X × x²) pour métriques uniquement)

**2. Écart très élevé (écart > 5):**
- Plusieurs passes nécessaires
- Convergence garantie si mathématiquement possible

**3. Configuration impossible:**
- Exemple: N=100, S=2, x=5 → maximum 8 rencontres/personne possible
- Distribution impossible sans écart
- Fonction fait best effort, logue WARNING

**4. Table unique (X=1):**
- Tous participants même table chaque session
- Équité parfaite automatique (tous rencontrent tous)

---

## Testing

### Test Coverage Target: ≥90%

**Module critique Phase 3**, couverture élevée requise.

### Tests Exhaustifs Requis

**1. Test planning déjà équitable → inchangé**
```python
def test_enforce_equity_already_equitable():
    """Test planning déjà équitable reste inchangé."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    baseline = generate_baseline(config, seed=42)
    improved = improve_planning(baseline, config)

    # Vérifier si déjà équitable
    metrics_before = compute_metrics(improved, config)
    if metrics_before.equity_gap > 1:
        pytest.skip("Baseline pas équitable, test non applicable")

    # Copier state
    tables_before = [[set(t) for t in s.tables] for s in improved.sessions]

    # Appliquer enforcement
    equitable = enforce_equity(improved, config)

    # Vérifier inchangé
    for s_idx, session in enumerate(equitable.sessions):
        for t_idx, table in enumerate(session.tables):
            assert table == tables_before[s_idx][t_idx]
```

**2. Test planning déséquilibré → écart ≤1**
```python
def test_enforce_equity_unbalanced_to_balanced():
    """Test planning déséquilibré ramené à écart ≤1."""
    # Créer planning manuellement avec écart = 3
    # (Construction dépend de géométrie, exemple simplifié)
    config = PlanningConfig(N=20, X=4, x=5, S=4)

    # Construire sessions déséquilibrées
    # Session 0: participant 0 dans table avec 1,2,3,4 → 4 rencontres
    # Session 1: participant 0 dans table avec 5,6,7,8 → +4 = 8 rencontres
    # ...
    # Participant 19 isolé dans petites tables
    # Résultat: écart significatif

    # Pour simplification, utiliser baseline + modifier manuellement
    baseline = generate_baseline(config, seed=99)
    # Forcer déséquilibre (manipulation directe)

    metrics_before = compute_metrics(baseline, config)

    equitable = enforce_equity(baseline, config)
    metrics_after = compute_metrics(equitable, config)

    assert metrics_after.equity_gap <= 1
    assert metrics_after.equity_gap < metrics_before.equity_gap
```

**3. Test métriques finales confirment équité**
```python
@pytest.mark.parametrize("N,X,x,S", [
    (30, 5, 6, 6),
    (50, 10, 5, 8),
    (100, 20, 5, 10),
])
def test_enforce_equity_guarantees_fr6(N, X, x, S):
    """Test garantie FR6 pour plusieurs configs."""
    config = PlanningConfig(N=N, X=X, x=x, S=S)

    # Pipeline complet
    baseline = generate_baseline(config, seed=42)
    improved = improve_planning(baseline, config, max_iterations=30)
    equitable = enforce_equity(improved, config)

    # Métriques finales
    metrics = compute_metrics(equitable, config)

    # Garantie FR6
    assert metrics.equity_gap <= 1, f"FR6 violée: écart={metrics.equity_gap} pour N={N}"

    # Vérifier tous participants dans [min, min+1]
    for count in metrics.unique_meetings_per_person:
        assert count >= metrics.min_unique
        assert count <= metrics.min_unique + 1
```

**4. Test performance N=300 <2s**
```python
import time
import pytest

@pytest.mark.slow
def test_enforce_equity_performance_n300():
    """Test performance enforcement N=300 <2s."""
    config = PlanningConfig(N=300, X=60, x=5, S=15)

    baseline = generate_baseline(config, seed=42)
    improved = improve_planning(baseline, config, max_iterations=20)

    # Mesurer temps enforcement uniquement
    start = time.time()
    equitable = enforce_equity(improved, config)
    elapsed = time.time() - start

    assert elapsed < 2.0, f"Enforcement trop lent: {elapsed:.3f}s (limite 2s)"

    # Vérifier équité finale
    metrics = compute_metrics(equitable, config)
    assert metrics.equity_gap <= 1
```

**5. Test planning valide après enforcement**
```python
def test_enforce_equity_valid_output():
    """Test planning post-enforcement valide."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    baseline = generate_baseline(config, seed=42)
    improved = improve_planning(baseline, config)
    equitable = enforce_equity(improved, config)

    # Vérifier invariants
    for session in equitable.sessions:
        all_p = set()
        for table in session.tables:
            all_p.update(table)
        assert len(all_p) == config.N
        assert all_p == set(range(config.N))

        sizes = [len(t) for t in session.tables]
        assert max(sizes) - min(sizes) <= 1  # FR7
```

**6. Test logging messages**
```python
def test_enforce_equity_logging(caplog):
    """Test messages logging Phase 3."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    baseline = generate_baseline(config, seed=42)
    improved = improve_planning(baseline, config)

    with caplog.at_level(logging.INFO):
        equitable = enforce_equity(improved, config)

    # Vérifier présence message final
    assert any("Équité" in record.message for record in caplog.records)
```

### Commandes de Test

```bash
# Tests unitaires rapides
pytest tests/test_optimizer.py::test_enforce_equity -v -m "not slow"

# Tests performance
pytest tests/test_optimizer.py::test_enforce_equity -v -m "slow"

# Tous tests optimizer
pytest tests/test_optimizer.py -v

# Couverture
pytest tests/test_optimizer.py --cov=src.optimizer --cov-report=term --cov-fail-under=90

# Type checking
mypy src/optimizer.py --strict
```

---

## QA Gate

**Fichier:** `docs/qa/gates/2.3-enforce-equity.yml`

```yaml
story: 2.3-enforce-equity
checks:
  - name: Unit Tests (Fast)
    command: pytest tests/test_optimizer.py::test_enforce_equity -v -m "not slow"
    expected: All tests pass

  - name: Performance Tests (Slow)
    command: pytest tests/test_optimizer.py::test_enforce_equity_performance -v -m "slow"
    expected: N=300 enforcement <2s

  - name: FR6 Guarantee Test
    command: pytest tests/test_optimizer.py::test_enforce_equity_guarantees_fr6 -v
    expected: equity_gap ≤ 1 for all configs

  - name: Coverage
    command: pytest tests/test_optimizer.py --cov=src.optimizer --cov-report=term --cov-fail-under=90
    expected: Coverage ≥90%

  - name: Type Checking
    command: mypy src/optimizer.py --strict
    expected: No errors

  - name: Code Formatting
    command: black --check src/optimizer.py tests/test_optimizer.py
    expected: All files formatted

  - name: Linting
    command: ruff check src/optimizer.py tests/test_optimizer.py
    expected: No violations
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used

_À compléter par le dev agent_

### Debug Log References

_À compléter par le dev agent_

### Completion Notes List

_À compléter par le dev agent_

### File List

_À compléter par le dev agent_

---

## QA Results

_À compléter par le QA agent_

---

**Definition of Done:**
- [ ] Tous les AC (1-8) sont satisfaits
- [ ] Toutes les tâches et sous-tâches sont complétées
- [ ] `enforce_equity()` implémentée dans `src/optimizer.py`
- [ ] Tests unitaires `test_enforce_equity_*` dans `tests/test_optimizer.py`
- [ ] Test planning déjà équitable: retourné inchangé
- [ ] Test déséquilibré → équitable: écart ≤1 garanti
- [ ] Test garantie FR6: equity_gap ≤ 1 pour multiples configs
- [ ] Test performance: N=300 enforcement <2s (`@pytest.mark.slow`)
- [ ] Test validité: planning respecte tous invariants
- [ ] Couverture ≥90% globale optimizer.py
- [ ] `mypy --strict` passe sans erreur
- [ ] `black` et `ruff` passent sans erreur
- [ ] Logging Phase 3: écart initial, équité atteinte
- [ ] QA Gate YAML créé dans `docs/qa/gates/2.3-enforce-equity.yml`
- [ ] Docstring complète avec garantie FR6, complexité O(S×N)
- [ ] **Granularité:** 1 story = 1 PR (enforcement équité uniquement)
