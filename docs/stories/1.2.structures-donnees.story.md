# Story 1.2: Définir les Structures de Données Fondamentales

## Status

**Draft**

---

## Story

**As a** développeur,
**I want** des dataclasses Python typées représentant les entités du domaine,
**so that** je peux manipuler les plannings, sessions, et configurations de manière type-safe et testable.

---

## Acceptance Criteria

1. Un module `src/models.py` contient une dataclass `Planning` représentant une liste de sessions
2. Une dataclass `Session` représente une liste de tables pour une session donnée
3. Une dataclass `Table` (ou type alias `Set[int]`) représente un ensemble de participant IDs
4. Une dataclass `PlanningConfig` contient les paramètres d'entrée : N, X, x, S avec validation dans `__post_init__`
5. Une dataclass `PlanningMetrics` contient toutes les métriques de qualité définies dans FR8-FR9
6. Tous les types sont documentés avec docstrings Google style
7. Les tests unitaires dans `tests/test_models.py` valident :
   - La création valide d'un `PlanningConfig` avec paramètres corrects
   - Le rejet avec exception pour paramètres invalides (N≤0, X×x<N, etc.) selon FR2
   - L'immutabilité ou mutabilité contrôlée des structures
8. `mypy src/models.py` passe sans erreur avec mode strict

---

## Tasks / Subtasks

- [ ] **Task 1: Créer le module models.py avec imports et type aliases** (AC: 1, 3)
  - [ ] Créer `src/models.py`
  - [ ] Importer `dataclasses` (dataclass, field) et `typing` (List, Set, Dict)
  - [ ] Définir type aliases: `ParticipantID = int`, `TableID = int`, `SessionID = int`, `Table = Set[ParticipantID]`

- [ ] **Task 2: Implémenter dataclass PlanningConfig** (AC: 4)
  - [ ] Créer `@dataclass(frozen=True)` PlanningConfig avec champs N, X, x, S (tous int)
  - [ ] Ajouter docstring Google style
  - [ ] Implémenter `__post_init__` pour validation des types (TypeError si non-int)
  - [ ] Vérifier immutabilité (frozen=True)

- [ ] **Task 3: Implémenter dataclass Session** (AC: 2)
  - [ ] Créer `@dataclass` Session avec champs: session_id (SessionID), tables (List[Table])
  - [ ] Ajouter docstring Google style: "Une session de networking avec plusieurs tables"

- [ ] **Task 4: Implémenter dataclass Planning** (AC: 1)
  - [ ] Créer `@dataclass` Planning avec champs: sessions (List[Session]), config (PlanningConfig)
  - [ ] Ajouter docstring Google style: "Planning complet sur toutes les sessions"

- [ ] **Task 5: Implémenter dataclass PlanningMetrics** (AC: 5)
  - [ ] Créer `@dataclass` PlanningMetrics avec champs FR8-FR9:
    - total_unique_pairs: int
    - total_repeat_pairs: int
    - unique_meetings_per_person: List[int]
    - min_unique, max_unique: int
    - mean_unique: float
    - std_unique: float
    - table_sizes_per_session: List[Dict[int, int]]
  - [ ] Implémenter @property equity_gap -> int retournant max_unique - min_unique
  - [ ] Ajouter docstring Google style avec description de chaque champ

- [ ] **Task 6: Implémenter InvalidConfigurationError** (AC: 4)
  - [ ] Créer classe `InvalidConfigurationError(Exception)` avec docstring
  - [ ] Docstring: "Exception levée pour configuration invalide"

- [ ] **Task 7: Écrire tests unitaires dans test_models.py** (AC: 7, 8)
  - [ ] Créer `tests/test_models.py`
  - [ ] Importer pytest et models
  - [ ] Test: création valide PlanningConfig(N=30, X=5, x=6, S=6)
  - [ ] Test: rejet TypeError pour N=30.5 (non-int)
  - [ ] Test: création valide Planning avec sessions vides
  - [ ] Test: création valide Session avec tables vides
  - [ ] Test: création valide PlanningMetrics avec toutes valeurs
  - [ ] Test: PlanningMetrics.equity_gap calcule correctement max - min
  - [ ] Test: immutabilité PlanningConfig (frozen=True)
  - [ ] Ajouter docstrings aux tests

- [ ] **Task 8: Valider mypy strict** (AC: 8)
  - [ ] Exécuter `mypy src/models.py --strict`
  - [ ] Corriger toutes erreurs de type
  - [ ] Vérifier que tous les champs ont des type hints explicites

- [ ] **Task 9: Exécuter tous les tests**
  - [ ] `pytest tests/test_models.py -v`
  - [ ] `pytest --cov=src/models --cov-report=term`
  - [ ] Vérifier couverture ≥95% (cible pour ce module)

---

## Dev Notes

### Dépendance sur Story Précédente

**Story 1.1 doit être complétée** - Cette story nécessite la structure `src/` et la configuration pytest de Story 1.1.

### Dataclasses Exactes à Implémenter

[Source: docs/architecture/interfaces-entre-modules.md#3.1]

**Copier ces dataclasses EXACTEMENT :**

```python
from dataclasses import dataclass, field
from typing import List, Set, Dict

# Type alias pour clarté
ParticipantID = int
TableID = int
SessionID = int
Table = Set[ParticipantID]

@dataclass(frozen=True)
class PlanningConfig:
    """Configuration d'un événement de networking."""
    N: int  # Nombre de participants
    X: int  # Nombre de tables
    x: int  # Capacité maximale par table
    S: int  # Nombre de sessions

    def __post_init__(self):
        """Validation basique des types (validation logique dans validation.py)."""
        if not all(isinstance(v, int) for v in [self.N, self.X, self.x, self.S]):
            raise TypeError("Tous les paramètres doivent être des entiers")

@dataclass
class Session:
    """Une session de networking avec plusieurs tables."""
    session_id: SessionID
    tables: List[Table]  # List[Set[ParticipantID]]

@dataclass
class Planning:
    """Planning complet sur toutes les sessions."""
    sessions: List[Session]
    config: PlanningConfig

@dataclass
class PlanningMetrics:
    """Métriques de qualité d'un planning."""
    # Métriques globales (FR8)
    total_unique_pairs: int
    total_repeat_pairs: int

    # Métriques par participant (FR8)
    unique_meetings_per_person: List[int]  # Taille N

    # Statistiques d'équité (FR9)
    min_unique: int
    max_unique: int
    mean_unique: float
    std_unique: float

    # Distribution tables (FR9)
    table_sizes_per_session: List[Dict[int, int]]  # [{size: count}, ...]

    # Indicateurs dérivés
    @property
    def equity_gap(self) -> int:
        """Écart max-min pour vérifier FR6."""
        return self.max_unique - self.min_unique

class InvalidConfigurationError(Exception):
    """Exception levée pour configuration invalide."""
    pass
```

### Choix de Design Importants

[Source: docs/architecture/modèles-de-données.md#4.1]

**Choix 1: Table = Set[int]**
- Garantit unicité des participants (pas de duplications dans une table)
- Vérification O(1) d'appartenance
- Alternative rejetée: List[int] (permet duplications)

**Choix 2: PlanningConfig frozen (immutable)**
- Thread-safe
- Hashable (peut être utilisé comme clé de dict)
- Prévient modifications accidentelles après création
- Alternative rejetée: Mutable (risques de side-effects)

**Choix 3: Planning contient sa config**
- Self-documenting: le planning sait ses paramètres
- Facilite export avec métadonnées
- Alternative rejetée: Passer config séparément (duplication paramètres)

**Choix 4: PlanningMetrics avec @property equity_gap**
- Métrique dérivée toujours cohérente (calculée à la demande)
- API propre (pas de duplication de données)
- Alternative rejetée: Stocker equity_gap (risque désynchronisation avec min/max)

### Invariants à Respecter

[Source: docs/architecture/modèles-de-données.md#4.2]

Les structures de données doivent permettre de vérifier ces invariants (vérification dans modules futurs, pas dans models.py) :

**Invariant 1:** Tous participants assignés exactement 1 fois par session
**Invariant 2:** Capacité tables respectée (len(table) ≤ config.x)
**Invariant 3:** Écart taille tables ≤1 (FR7)
**Invariant 4:** Équité ±1 (FR6) après pipeline complet (metrics.equity_gap ≤ 1)

### Validation dans __post_init__

**IMPORTANT:** PlanningConfig.__post_init__ fait UNIQUEMENT validation des types (TypeError).

La validation logique (N≥2, X≥1, X×x≥N, etc.) sera faite dans `validation.py` (Story 1.3).

Ceci suit le principe de **Séparation des Préoccupations** :
- models.py : structures de données pures
- validation.py : logique de validation métier

### Type Hints et Mypy Strict

Tous les champs doivent avoir des type hints explicites pour passer mypy strict :
- Pas de `Any`
- Pas de types implicites
- Utiliser `List[X]` pas `list`
- Utiliser `Set[X]` pas `set`
- Utiliser `Dict[K, V]` pas `dict`

---

## Testing

### Framework et Structure

[Source: docs/architecture/stratégie-de-testing.md#5.2]

**Test file:** `tests/test_models.py`
**Couverture cible:** ≥95% (module fondamental)

### Tests Unitaires Requis

**1. Test création valide PlanningConfig**
```python
def test_planning_config_valid_creation():
    """Test création valide avec tous paramètres corrects."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    assert config.N == 30
    assert config.X == 5
    assert config.x == 6
    assert config.S == 6
```

**2. Test validation types PlanningConfig**
```python
def test_planning_config_rejects_non_int():
    """Test rejet TypeError pour paramètres non-int."""
    with pytest.raises(TypeError, match="doivent être des entiers"):
        PlanningConfig(N=30.5, X=5, x=6, S=6)
```

**3. Test immutabilité PlanningConfig**
```python
def test_planning_config_immutable():
    """Test frozen=True empêche modifications."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    with pytest.raises(AttributeError):
        config.N = 50  # Doit lever FrozenInstanceError
```

**4. Test création Planning valide**
```python
def test_planning_creation():
    """Test création Planning avec sessions."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    sessions = []
    planning = Planning(sessions=sessions, config=config)
    assert planning.config == config
    assert len(planning.sessions) == 0
```

**5. Test PlanningMetrics.equity_gap**
```python
def test_planning_metrics_equity_gap():
    """Test calcul equity_gap (max - min)."""
    metrics = PlanningMetrics(
        total_unique_pairs=100,
        total_repeat_pairs=5,
        unique_meetings_per_person=[10, 12, 11, 10],
        min_unique=10,
        max_unique=12,
        mean_unique=10.75,
        std_unique=0.829,
        table_sizes_per_session=[]
    )
    assert metrics.equity_gap == 2  # 12 - 10
```

**6. Test Session et Table**
```python
def test_session_creation():
    """Test création Session avec tables."""
    table1 = {0, 1, 2, 3}  # Set[int]
    table2 = {4, 5, 6, 7}
    session = Session(session_id=0, tables=[table1, table2])
    assert session.session_id == 0
    assert len(session.tables) == 2
    assert 0 in session.tables[0]
```

### Commandes de Test

```bash
# Tests unitaires
pytest tests/test_models.py -v

# Couverture
pytest tests/test_models.py --cov=src.models --cov-report=term --cov-report=html

# Type checking
mypy src/models.py --strict

# Tous les checks
black src/models.py tests/test_models.py
ruff check src/models.py tests/test_models.py
mypy src/models.py --strict
pytest tests/test_models.py -v
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used

_À compléter par le dev agent_

### Debug Log References

_À compléter par le dev agent_

### Completion Notes List

_À compléter par le dev agent_

### File List

_À compléter par le dev agent_

---

## QA Results

_À compléter par le QA agent_

---

**Definition of Done:**
- [ ] Tous les AC (1-8) sont satisfaits
- [ ] Toutes les tâches et sous-tâches sont complétées
- [ ] `src/models.py` créé avec toutes les dataclasses
- [ ] `tests/test_models.py` créé avec tous les tests
- [ ] `pytest tests/test_models.py` passe avec succès
- [ ] `mypy src/models.py --strict` passe sans erreur
- [ ] `black` et `ruff` passent sans erreur
- [ ] Couverture ≥95% pour `src/models.py`
- [ ] Tous les docstrings Google style présents
- [ ] Type hints complets sur tous les champs
