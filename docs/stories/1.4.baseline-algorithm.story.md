# Story 1.4: Implémenter l'Algorithme de Génération Baseline (Round-Robin)

## Status

**Draft**

---

## Story

**As a** développeur,
**I want** un algorithme de génération rapide produisant un planning valide initial,
**so that** le système peut toujours fournir un résultat même sans optimisation avancée.

---

## Acceptance Criteria

1. Un module `src/baseline.py` contient une fonction `generate_baseline(config: PlanningConfig, seed: int = 42) -> Planning`
2. L'algorithme implémente une stratégie de rotation systématique (round-robin généralisé avec stride)
3. Pour chaque session, tous les N participants sont assignés à exactement une table
4. La fonction garantit que chaque table respecte la contrainte de capacité x
5. La gestion des tables partielles est correcte : si N n'est pas multiple de x, les participants sont répartis avec écart de taille ≤1 entre tables (FR7)
6. L'algorithme est déterministe : à seed identique, génère le même planning (NFR11)
7. Les tests dans `tests/test_baseline.py` vérifient :
   - Planning valide pour config simple (N=30, X=5, x=6, S=6)
   - Planning valide pour tables partielles (N=37, X=6, x=7)
   - Déterminisme (2 appels avec même seed = même résultat)
   - Performance : génération pour N=100 en <1s
8. Aucun participant n'est oublié ou dupliqué dans une session

---

## Tasks / Subtasks

- [ ] **Task 1: Créer module baseline.py avec imports** (AC: 1)
  - [ ] Créer `src/baseline.py`
  - [ ] Importer `random`, `Planning`, `PlanningConfig`, `Session`, `Table` (Set[int])
  - [ ] Importer `List` from typing

- [ ] **Task 2: Implémenter generate_baseline() - logique core** (AC: 1, 2, 3, 4)
  - [ ] Créer fonction `generate_baseline(config: PlanningConfig, seed: int = 42) -> Planning`
  - [ ] Ajouter docstring Google style complète (stratégie, args, returns, guarantees, performance)
  - [ ] Initialiser `random.seed(seed)` pour déterminisme (NFR11)
  - [ ] Calculer `base_table_size = config.N // config.X` et `remainder = config.N % config.X`
  - [ ] Créer liste vide `sessions: List[Session]`

- [ ] **Task 3: Implémenter rotation round-robin avec stride** (AC: 2, 6)
  - [ ] Pour chaque session (range(config.S)):
    - Créer liste participants = list(range(config.N))
    - Calculer stride = (session_id * 17 + 1) % config.N (coprime pour couverture)
    - Appliquer rotation: participants = [participants[(i * stride) % config.N] for i in range(config.N)]
  - [ ] Vérifier déterminisme: même seed → même ordre rotation

- [ ] **Task 4: Implémenter gestion tables partielles** (AC: 5 - FR7)
  - [ ] Distribuer participants dans tables avec gestion remainder:
    - Premières `remainder` tables ont `base_table_size + 1` participants
    - Tables restantes ont `base_table_size` participants
  - [ ] Créer Set[int] pour chaque table (garantit unicité)
  - [ ] Vérifier écart taille ≤1: max(sizes) - min(sizes) <= 1

- [ ] **Task 5: Assembler Planning et retourner** (AC: 3, 8)
  - [ ] Pour chaque session, créer Session(session_id, tables)
  - [ ] Ajouter à liste sessions
  - [ ] Créer et retourner Planning(sessions, config)
  - [ ] Vérifier tous participants présents: sum(len(table) for table in session.tables) == config.N

- [ ] **Task 6: Créer tests unitaires test_baseline.py** (AC: 7)
  - [ ] Créer `tests/test_baseline.py`
  - [ ] Test: config simple (N=30, X=5, x=6, S=6) génère planning valide
    - Vérifier 6 sessions, 5 tables/session
    - Vérifier tous participants 0-29 présents chaque session
    - Vérifier tailles tables correctes (toutes 6)
  - [ ] Test: tables partielles (N=37, X=6, x=7) génère planning correct
    - Vérifier remainder=1 (37 % 6 = 1)
    - Vérifier 1 table avec 7 participants, 5 tables avec 6
    - Vérifier écart taille ≤1
  - [ ] Test: déterminisme (seed=42)
    - Générer planning1 avec seed=42
    - Générer planning2 avec seed=42
    - Vérifier planning1 == planning2 (mêmes tables, même ordre)
  - [ ] Test: seed différent génère planning différent
    - Générer avec seed=42 vs seed=99
    - Vérifier plannings différents

- [ ] **Task 7: Créer test performance** (AC: 7 - NFR1)
  - [ ] Test: `@pytest.mark.slow` pour performance N=100
  - [ ] Config (N=100, X=20, x=5, S=10)
  - [ ] Mesurer temps avec time.time()
  - [ ] Assert temps < 1.0 seconde
  - [ ] Ajouter au fichier test_baseline.py

- [ ] **Task 8: Valider couverture et qualité** (AC: 7)
  - [ ] `pytest tests/test_baseline.py -v`
  - [ ] `pytest tests/test_baseline.py --cov=src.baseline --cov-report=term`
  - [ ] Vérifier couverture ≥95%
  - [ ] `mypy src/baseline.py --strict`
  - [ ] `black` et `ruff` passent

- [ ] **Task 9: Créer QA Gate YAML**
  - [ ] Créer `docs/qa/gates/1.4-baseline-algorithm.yml`
  - [ ] Définir checks: pytest, mypy, black, ruff, coverage
  - [ ] Définir expected outputs et commands

---

## Dev Notes

### Dépendance sur Stories Précédentes

**Stories 1.1, 1.2, 1.3 doivent être complétées** :
- 1.1: Structure projet + pytest
- 1.2: PlanningConfig, Planning, Session, Table
- 1.3: validate_config (non utilisé ici mais dans intégration)

### Implémentation Exacte - Algorithme Round-Robin avec Stride

[Source: docs/architecture/interfaces-entre-modules.md#3.3]

```python
from typing import List
import random
from src.models import Planning, PlanningConfig, Session, Table

def generate_baseline(config: PlanningConfig, seed: int = 42) -> Planning:
    """
    Génère un planning baseline valide via rotation round-robin généralisée.

    Stratégie:
    - Rotation systématique avec stride pour mélange rapide
    - Gestion automatique des tables partielles (N non-multiple de x)
    - Complexité O(N × S)

    Args:
        config: Configuration validée
        seed: Seed aléatoire pour reproductibilité (NFR11)

    Returns:
        Planning valide avec tous participants assignés chaque session

    Guarantees:
        - Tous les N participants assignés exactement 1 fois par session
        - Écart de taille entre tables ≤1 (FR7)
        - Déterministe : même seed → même résultat

    Performance:
        O(N × S) - Linéaire, <100ms pour N=1000, S=25
    """
    random.seed(seed)
    sessions: List[Session] = []

    # Calcul répartition participants par table
    base_table_size = config.N // config.X
    remainder = config.N % config.X

    for session_id in range(config.S):
        tables: List[Table] = []
        participants = list(range(config.N))

        # Rotation avec stride (mélange entre sessions)
        stride = (session_id * 17 + 1) % config.N  # Coprime avec N pour couverture
        participants = [participants[(i * stride) % config.N] for i in range(config.N)]

        # Distribution dans tables
        idx = 0
        for table_id in range(config.X):
            # Tables avec remainder ont +1 participant
            table_size = base_table_size + (1 if table_id < remainder else 0)
            table = set(participants[idx:idx + table_size])
            tables.append(table)
            idx += table_size

        sessions.append(Session(session_id=session_id, tables=tables))

    return Planning(sessions=sessions, config=config)
```

### Gestion Tables Partielles (FR7)

[Source: docs/architecture/décisions-techniques.md#Décision-7]

**Problème:** Si N=37, X=6, x=7 → 6×7=42 > 37, comment répartir ?

**Solution:**
```python
base_size = N // X  # 37 // 6 = 6
remainder = N % X   # 37 % 6 = 1

# Tables: [7, 6, 6, 6, 6, 6] → écart ≤1 ✓
# Première table (table_id=0) a 6+1=7 participants
# Tables restantes (table_id=1-5) ont 6 participants
```

**Garantie:** `max(sizes) - min(sizes) ≤ 1`

### Déterminisme et Seed (NFR11)

[Source: docs/prd.md - NFR11]

**Exigence:** "Reproductibilité - à entrées identiques et seed aléatoire fixe, le système doit produire le même planning"

**Implémentation:**
- `random.seed(seed)` au début de la fonction
- Rotation déterministe: stride calculé à partir de session_id (pas d'aléatoire)
- Même seed + même config → exactement même planning

**Test de déterminisme obligatoire:**
```python
def test_generate_baseline_deterministic():
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    planning1 = generate_baseline(config, seed=42)
    planning2 = generate_baseline(config, seed=42)

    # Vérifier identité complète
    for s_idx in range(6):
        for t_idx in range(5):
            assert planning1.sessions[s_idx].tables[t_idx] == \
                   planning2.sessions[s_idx].tables[t_idx]
```

### Rotation avec Stride Coprime

[Source: docs/architecture/décisions-techniques.md#Décision-3]

**Pourquoi stride = (session_id * 17 + 1) % N ?**

- **17 est coprime** avec la plupart des N (sauf multiples de 17)
- Assure couverture complète des participants sur sessions
- Mélange efficace sans blocs statiques
- Déterministe (dépend uniquement de session_id)

**Alternative si N est multiple de 17:** stride fonctionne toujours car `stride % N` reste valide.

### Complexité Algorithmique

**Temps:** O(N × S)
- Boucle externe: S sessions
- Pour chaque session: créer liste N participants, rotation O(N), distribution O(N)
- Total: O(S × N)

**Mémoire:** O(N × S)
- Stockage Planning avec S sessions × X tables × ~(N/X) participants
- Historique pas calculé ici (Story 1.5)

---

## Testing

### Test Coverage Target: ≥95%

[Source: docs/architecture/stratégie-de-testing.md#5.2]

**Module critique:** baseline.py est la Phase 1 du pipeline, couverture élevée requise.

### Tests Exhaustifs Requis

**1. Test config simple (N=30, X=5, x=6, S=6)**
```python
def test_generate_baseline_simple_config():
    """Test génération avec config simple sans remainder."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    planning = generate_baseline(config, seed=42)

    assert len(planning.sessions) == 6
    for session in planning.sessions:
        assert len(session.tables) == 5
        # Vérifier tous participants présents
        all_participants = set()
        for table in session.tables:
            all_participants.update(table)
        assert all_participants == set(range(30))
        # Vérifier tailles tables
        assert all(len(table) == 6 for table in session.tables)
```

**2. Test tables partielles (N=37, X=6, x=7)**
```python
def test_generate_baseline_partial_tables():
    """Test gestion tables partielles avec remainder."""
    config = PlanningConfig(N=37, X=6, x=7, S=5)
    planning = generate_baseline(config, seed=42)

    for session in planning.sessions:
        sizes = [len(table) for table in session.tables]
        assert min(sizes) == 6  # base_size
        assert max(sizes) == 7  # base_size + 1
        assert max(sizes) - min(sizes) <= 1  # FR7
        assert sum(sizes) == 37  # Tous participants
```

**3. Test déterminisme**
```python
def test_generate_baseline_deterministic():
    """Test reproductibilité avec même seed."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    planning1 = generate_baseline(config, seed=42)
    planning2 = generate_baseline(config, seed=42)

    # Vérifier identité session par session
    for s in range(6):
        for t in range(5):
            assert planning1.sessions[s].tables[t] == planning2.sessions[s].tables[t]
```

**4. Test seed différent produit planning différent**
```python
def test_generate_baseline_different_seed():
    """Test seed différent génère planning différent."""
    config = PlanningConfig(N=30, X=5, x=6, S=6)
    planning1 = generate_baseline(config, seed=42)
    planning2 = generate_baseline(config, seed=99)

    # Au moins une table doit être différente
    different = False
    for s in range(6):
        for t in range(5):
            if planning1.sessions[s].tables[t] != planning2.sessions[s].tables[t]:
                different = True
                break
    assert different
```

**5. Test performance N=100 <1s**
```python
import time

@pytest.mark.slow
def test_generate_baseline_performance_n100():
    """Test performance NFR1: N≤100 en <1s."""
    config = PlanningConfig(N=100, X=20, x=5, S=10)
    start = time.time()
    planning = generate_baseline(config, seed=42)
    elapsed = time.time() - start

    assert elapsed < 1.0, f"Temps: {elapsed:.3f}s (limite 1s)"
    assert len(planning.sessions) == 10
```

### Commandes de Test

```bash
# Tests unitaires (sans slow)
pytest tests/test_baseline.py -v -m "not slow"

# Tests performance (slow)
pytest tests/test_baseline.py -v -m "slow"

# Tous tests
pytest tests/test_baseline.py -v

# Couverture
pytest tests/test_baseline.py --cov=src.baseline --cov-report=term --cov-fail-under=95

# Type checking
mypy src/baseline.py --strict

# Qualité code
black src/baseline.py tests/test_baseline.py
ruff check src/baseline.py tests/test_baseline.py
```

---

## QA Gate

**Fichier:** `docs/qa/gates/1.4-baseline-algorithm.yml`

```yaml
story: 1.4-baseline-algorithm
checks:
  - name: Unit Tests
    command: pytest tests/test_baseline.py -v -m "not slow"
    expected: All tests pass

  - name: Performance Tests
    command: pytest tests/test_baseline.py -v -m "slow"
    expected: All tests pass, N=100 <1s

  - name: Coverage
    command: pytest tests/test_baseline.py --cov=src.baseline --cov-report=term --cov-fail-under=95
    expected: Coverage ≥95%

  - name: Type Checking
    command: mypy src/baseline.py --strict
    expected: No errors

  - name: Code Formatting
    command: black --check src/baseline.py tests/test_baseline.py
    expected: All files formatted

  - name: Linting
    command: ruff check src/baseline.py tests/test_baseline.py
    expected: No violations
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used

_À compléter par le dev agent_

### Debug Log References

_À compléter par le dev agent_

### Completion Notes List

_À compléter par le dev agent_

### File List

_À compléter par le dev agent_

---

## QA Results

_À compléter par le QA agent_

---

**Definition of Done:**
- [ ] Tous les AC (1-8) sont satisfaits
- [ ] Toutes les tâches et sous-tâches sont complétées
- [ ] `src/baseline.py` créé avec generate_baseline()
- [ ] `tests/test_baseline.py` créé avec tous les tests
- [ ] Tests unitaires passent (pytest -m "not slow")
- [ ] Tests performance passent (pytest -m "slow"), N=100 <1s
- [ ] Couverture ≥95% pour `src/baseline.py`
- [ ] `mypy --strict` passe sans erreur
- [ ] `black` et `ruff` passent sans erreur
- [ ] Déterminisme vérifié (seed=42 → même planning)
- [ ] Tables partielles gèrent correctement FR7 (écart ≤1)
- [ ] QA Gate YAML créé dans `docs/qa/gates/1.4-baseline-algorithm.yml`
- [ ] Docstring Google style complète
- [ ] **Granularité:** 1 story = 1 PR (ne pas combiner avec autres stories)
