# Story 1.5: Implémenter le Calcul de l'Historique des Rencontres

## Status

**Draft**

---

## Story

**As a** développeur,
**I want** une fonction calculant quels participants se sont déjà rencontrés,
**so that** je peux mesurer les répétitions et préparer les phases d'optimisation futures.

---

## Acceptance Criteria

1. Un module `src/metrics.py` contient une fonction `compute_meeting_history(planning: Planning) -> Set[Tuple[int, int]]`
2. La fonction retourne l'ensemble de toutes les paires de participants qui se sont rencontrés au moins une fois
3. Les paires sont normalisées : `(min(i,j), max(i,j))` pour éviter duplications `(i,j)` et `(j,i)`
4. La complexité est O(S × X × x²) dans le pire cas
5. Les tests dans `tests/test_metrics.py` vérifient :
   - Planning sans répétitions : `len(met_pairs)` = nombre de paires attendu
   - Planning avec répétitions connues : paires détectées correctement
   - Normalisation des paires : `(0,1)` présent, pas `(1,0)`
6. La fonction gère correctement les tables de tailles variables

---

## Tasks / Subtasks

- [ ] **Task 1: Créer module metrics.py avec imports** (AC: 1)
  - [ ] Créer `src/metrics.py`
  - [ ] Importer `Set`, `Tuple`, `List`, `Dict` from typing
  - [ ] Importer `Planning`, `PlanningConfig` from src.models
  - [ ] Définir type alias: `MeetingHistory = Set[Tuple[int, int]]`

- [ ] **Task 2: Implémenter compute_meeting_history()** (AC: 1, 2, 3, 4, 6)
  - [ ] Créer fonction `compute_meeting_history(planning: Planning) -> MeetingHistory`
  - [ ] Ajouter docstring Google style (args, returns, complexity)
  - [ ] Initialiser `met_pairs: MeetingHistory = set()`
  - [ ] Pour chaque session dans planning.sessions:
    - Pour chaque table dans session.tables:
      - Convertir table (Set[int]) en liste
      - Générer toutes paires (i, j) avec i < j
      - Normaliser: (min(p1, p2), max(p1, p2))
      - Ajouter à met_pairs
  - [ ] Retourner met_pairs

- [ ] **Task 3: Optimiser génération paires normalisées** (AC: 3)
  - [ ] Utiliser double boucle for i in range(len(participants)), for j in range(i+1, len(participants))
  - [ ] Garantit automatiquement i < j (normalisation implicite)
  - [ ] Ajouter pair = (participants[i], participants[j]) en respectant min/max si participants pas triés

- [ ] **Task 4: Créer tests unitaires test_metrics.py** (AC: 5)
  - [ ] Créer `tests/test_metrics.py`
  - [ ] Test: planning simple sans répétitions
    - Créer planning manuel: 3 participants, 1 session, 1 table {0,1,2}
    - Appeler compute_meeting_history
    - Vérifier len(met_pairs) == 3: (0,1), (0,2), (1,2)
  - [ ] Test: planning avec répétitions
    - Session 1: table {0,1}, table {2,3}
    - Session 2: table {0,1}, table {2,3}
    - Vérifier len(met_pairs) == 2: (0,1), (2,3) (pas de duplications)
  - [ ] Test: normalisation paires
    - Créer table {5, 1, 3}
    - Vérifier paires: (1,3), (1,5), (3,5) (ordre min, max)
    - Vérifier (1,3) présent, pas (3,1)
  - [ ] Test: tables de tailles variables
    - Session avec table {0,1,2,3} (4 participants) et table {4,5} (2 participants)
    - Vérifier 6 paires table 1: C(4,2) = 6
    - Vérifier 1 paire table 2: C(2,2) = 1
    - Total 7 paires

- [ ] **Task 5: Valider complexité O(S×X×x²)** (AC: 4)
  - [ ] Ajouter commentaire dans code expliquant complexité
  - [ ] Boucle externe: S sessions → O(S)
  - [ ] Boucle interne: X tables → O(X)
  - [ ] Génération paires table: C(x,2) ≈ x²/2 → O(x²)
  - [ ] Total: O(S × X × x²)

- [ ] **Task 6: Valider couverture et qualité**
  - [ ] `pytest tests/test_metrics.py -v`
  - [ ] `pytest tests/test_metrics.py --cov=src.metrics --cov-report=term`
  - [ ] Vérifier couverture ≥90% (cible pour ce module)
  - [ ] `mypy src/metrics.py --strict`
  - [ ] `black` et `ruff` passent

- [ ] **Task 7: Créer QA Gate YAML**
  - [ ] Créer `docs/qa/gates/1.5-meeting-history.yml`
  - [ ] Définir checks: pytest, mypy, black, ruff, coverage ≥90%

---

## Dev Notes

### Dépendance sur Stories Précédentes

**Stories 1.1, 1.2, 1.4 doivent être complétées** :
- 1.1: Structure projet + pytest
- 1.2: Planning, Session, Table (Set[int])
- 1.4: generate_baseline (pour tests d'intégration futurs)

**Note:** Story 1.3 (validation) pas nécessaire pour cette story.

### Séparation Claire Meeting History vs Metrics

**IMPORTANT:** Cette story implémente **uniquement** `compute_meeting_history()`.

La Story 1.6 implémentera `compute_metrics()` qui **utilise** `compute_meeting_history()`.

**Raison de la séparation:**
- `compute_meeting_history`: primitive de bas niveau, réutilisable
- `compute_metrics`: calculs statistiques complexes basés sur historique
- Facilite tests et modularité

### Implémentation Exacte

[Source: docs/architecture/interfaces-entre-modules.md#3.4]

```python
from typing import Set, Tuple
from src.models import Planning

MeetingHistory = Set[Tuple[int, int]]  # Ensemble paires normalisées (min, max)

def compute_meeting_history(planning: Planning) -> MeetingHistory:
    """
    Calcule l'ensemble de toutes les paires de participants s'étant rencontrés.

    Args:
        planning: Planning à analyser

    Returns:
        Set de paires normalisées (i, j) avec i < j

    Complexity:
        O(S × X × x²) où x = taille moyenne table
    """
    met_pairs: MeetingHistory = set()

    for session in planning.sessions:
        for table in session.tables:
            participants = list(table)
            # Générer toutes les paires de cette table
            for i in range(len(participants)):
                for j in range(i + 1, len(participants)):
                    p1, p2 = participants[i], participants[j]
                    # Normalisation (min, max) pour éviter (i,j) et (j,i)
                    met_pairs.add((min(p1, p2), max(p1, p2)))

    return met_pairs
```

### Normalisation des Paires (min, max)

[Source: docs/architecture/modèles-de-données.md#4.2]

**Pourquoi normaliser ?**

Sans normalisation, les paires (0,1) et (1,0) seraient différentes dans le Set:
```python
pairs = {(0,1), (1,0)}  # 2 paires (INCORRECT)
```

Avec normalisation (min, max):
```python
pairs = {(0,1)}  # 1 paire (CORRECT)
```

**Implémentation:**
```python
# Méthode 1: explicite
pair = (min(p1, p2), max(p1, p2))

# Méthode 2: implicite (si boucle garantit i < j)
for i in range(len(participants)):
    for j in range(i + 1, len(participants)):  # j > i toujours
        pair = (participants[i], participants[j])
        # Mais participants[i] peut être > participants[j] !
        # Donc toujours utiliser min/max pour être sûr
```

**Recommandation:** Toujours utiliser `(min(p1, p2), max(p1, p2))` pour robustesse.

### Gestion Tables de Tailles Variables

[Source: docs/architecture/décisions-techniques.md#Décision-7]

La fonction doit correctement gérer:
- Tables pleines (taille x)
- Tables partielles (taille < x si remainder)
- Mix de tailles dans une même session

**Exemple:**
```python
# Session avec N=37, X=6, x=7
# Tables: [7, 6, 6, 6, 6, 6]

# Table 0 (7 participants): C(7,2) = 21 paires
# Tables 1-5 (6 participants chacune): C(6,2) = 15 paires × 5 = 75 paires
# Total: 21 + 75 = 96 paires
```

La fonction `compute_meeting_history()` génère exactement ces paires.

### Complexité Algorithmique Détaillée

**Complexité temps:** O(S × X × x²)

Analyse détaillée:
```python
for session in planning.sessions:           # O(S)
    for table in session.tables:            # O(X)
        participants = list(table)           # O(x)
        for i in range(len(participants)):   # O(x)
            for j in range(i+1, len(...)):   # O(x)
                # Opérations O(1)
```

Total: O(S × X × (x + x²)) = O(S × X × x²) car x² domine.

**Complexité mémoire:** O(S × X × x²) dans le pire cas
- Set peut contenir toutes les paires de toutes les tables
- Cas extrême: aucune répétition, toutes paires uniques

**Cas typique:** O(N²) car nombre max de paires uniques = C(N,2) ≈ N²/2

---

## Testing

### Test Coverage Target: ≥90%

[Source: docs/architecture/stratégie-de-testing.md#5.2]

**Module fondamental** pour Phase 2 (optimisation), couverture élevée requise.

### Tests Exhaustifs Requis

**1. Test planning simple sans répétitions**
```python
def test_compute_meeting_history_no_repeats():
    """Test calcul historique sans répétitions."""
    config = PlanningConfig(N=6, X=2, x=3, S=1)
    # Session 0: table {0,1,2}, table {3,4,5}
    session = Session(
        session_id=0,
        tables=[{0,1,2}, {3,4,5}]
    )
    planning = Planning(sessions=[session], config=config)

    met_pairs = compute_meeting_history(planning)

    # Table 1: (0,1), (0,2), (1,2) = 3 paires
    # Table 2: (3,4), (3,5), (4,5) = 3 paires
    # Total: 6 paires
    assert len(met_pairs) == 6
    assert (0,1) in met_pairs
    assert (0,2) in met_pairs
    assert (1,2) in met_pairs
    assert (3,4) in met_pairs
    assert (3,5) in met_pairs
    assert (4,5) in met_pairs
```

**2. Test planning avec répétitions**
```python
def test_compute_meeting_history_with_repeats():
    """Test détection répétitions (paire vue plusieurs fois)."""
    config = PlanningConfig(N=4, X=2, x=2, S=2)
    # Session 0: table {0,1}, table {2,3}
    # Session 1: table {0,1}, table {2,3}  # Répétition exacte
    sessions = [
        Session(session_id=0, tables=[{0,1}, {2,3}]),
        Session(session_id=1, tables=[{0,1}, {2,3}])
    ]
    planning = Planning(sessions=sessions, config=config)

    met_pairs = compute_meeting_history(planning)

    # Paires uniques: (0,1), (2,3) seulement (pas de duplications)
    assert len(met_pairs) == 2
    assert (0,1) in met_pairs
    assert (2,3) in met_pairs
```

**3. Test normalisation paires**
```python
def test_compute_meeting_history_normalization():
    """Test normalisation (min, max) des paires."""
    config = PlanningConfig(N=3, X=1, x=3, S=1)
    # Table non triée: {5, 1, 3}
    session = Session(session_id=0, tables=[{5,1,3}])
    planning = Planning(sessions=[session], config=config)

    met_pairs = compute_meeting_history(planning)

    # Paires normalisées: (1,3), (1,5), (3,5)
    assert len(met_pairs) == 3
    assert (1,3) in met_pairs
    assert (1,5) in met_pairs
    assert (3,5) in met_pairs

    # Vérifier pas de paires inversées
    assert (3,1) not in met_pairs
    assert (5,1) not in met_pairs
    assert (5,3) not in met_pairs
```

**4. Test tables tailles variables**
```python
def test_compute_meeting_history_variable_table_sizes():
    """Test gestion tables de tailles différentes."""
    config = PlanningConfig(N=6, X=2, x=4, S=1)
    # Table 1: {0,1,2,3} (4 participants) → C(4,2) = 6 paires
    # Table 2: {4,5} (2 participants) → C(2,2) = 1 paire
    session = Session(session_id=0, tables=[{0,1,2,3}, {4,5}])
    planning = Planning(sessions=[session], config=config)

    met_pairs = compute_meeting_history(planning)

    # Total: 6 + 1 = 7 paires
    assert len(met_pairs) == 7
    # Vérifier paires table 1
    assert (0,1) in met_pairs
    assert (0,2) in met_pairs
    assert (0,3) in met_pairs
    assert (1,2) in met_pairs
    assert (1,3) in met_pairs
    assert (2,3) in met_pairs
    # Vérifier paire table 2
    assert (4,5) in met_pairs
```

### Commandes de Test

```bash
# Tests unitaires
pytest tests/test_metrics.py::test_compute_meeting_history -v

# Couverture
pytest tests/test_metrics.py --cov=src.metrics --cov-report=term --cov-fail-under=90

# Type checking
mypy src/metrics.py --strict

# Qualité code
black src/metrics.py tests/test_metrics.py
ruff check src/metrics.py tests/test_metrics.py
```

---

## QA Gate

**Fichier:** `docs/qa/gates/1.5-meeting-history.yml`

```yaml
story: 1.5-meeting-history
checks:
  - name: Unit Tests
    command: pytest tests/test_metrics.py::test_compute_meeting_history -v
    expected: All tests pass

  - name: Coverage
    command: pytest tests/test_metrics.py --cov=src.metrics --cov-report=term --cov-fail-under=90
    expected: Coverage ≥90%

  - name: Type Checking
    command: mypy src/metrics.py --strict
    expected: No errors

  - name: Code Formatting
    command: black --check src/metrics.py tests/test_metrics.py
    expected: All files formatted

  - name: Linting
    command: ruff check src/metrics.py tests/test_metrics.py
    expected: No violations
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used

_À compléter par le dev agent_

### Debug Log References

_À compléter par le dev agent_

### Completion Notes List

_À compléter par le dev agent_

### File List

_À compléter par le dev agent_

---

## QA Results

_À compléter par le QA agent_

---

**Definition of Done:**
- [ ] Tous les AC (1-6) sont satisfaits
- [ ] Toutes les tâches et sous-tâches sont complétées
- [ ] `src/metrics.py` créé avec compute_meeting_history()
- [ ] `tests/test_metrics.py` créé avec tests historique
- [ ] Tests unitaires passent (pytest)
- [ ] Couverture ≥90% pour compute_meeting_history
- [ ] `mypy --strict` passe sans erreur
- [ ] `black` et `ruff` passent sans erreur
- [ ] Normalisation paires (min, max) vérifiée
- [ ] Tables tailles variables gérées correctement
- [ ] Complexité O(S×X×x²) documentée
- [ ] QA Gate YAML créé dans `docs/qa/gates/1.5-meeting-history.yml`
- [ ] Docstring Google style complète
- [ ] **Granularité:** 1 story = 1 PR (séparée de Story 1.6 compute_metrics)
