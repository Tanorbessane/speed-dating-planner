# Story 2.7: Documentation de l'Optimisation

## Status

**Draft**

---

## Story

**As a** utilisateur technique,
**I want** une documentation expliquant comment fonctionne l'optimisation et comment interpréter les métriques,
**so that** je comprends la valeur ajoutée du système et comment configurer les paramètres avancés.

---

## Acceptance Criteria

1. Le fichier `docs/architecture/vue-densemble-de-larchitecture.md` est complété avec :
   - Description détaillée des 3 phases du pipeline
   - Explication de l'heuristique de swaps gloutons
   - Critères d'arrêt (plateau local, max_iterations)
   - Trade-offs équité vs répétitions minimales
2. Le `README.md` inclut une section "Comment ça marche ?" avec :
   - Schéma textuel du pipeline 3 phases
   - Exemple de métriques avant/après optimisation
3. Un fichier `examples/advanced_usage.py` démontre :
   - Utilisation de `generate_optimized_planning`
   - Affichage des métriques détaillées
   - Comparaison baseline vs optimisé
4. Le code de l'exemple s'exécute sans erreur et produit une sortie lisible
5. Les docstrings des fonctions d'optimisation expliquent la complexité algorithmique et les garanties

---

## Tasks / Subtasks

- [ ] **Task 1: Compléter architecture - Pipeline 3 phases** (AC: 1)
  - [ ] Éditer `docs/architecture/vue-densemble-de-larchitecture.md`
  - [ ] Ajouter section "3.7 Pipeline Hybride 3 Phases":
    - Phase 1 (Baseline): Round-robin, O(N×S), <100ms
    - Phase 2 (Amélioration Locale): Swaps gloutons, O(iter×S×X²×x²), ~1-3s N=100
    - Phase 3 (Enforcement Équité): Swaps ciblés, O(S×N), <1s N=300
  - [ ] Diagramme textuel flux de données
  - [ ] Garanties de chaque phase

- [ ] **Task 2: Documenter algorithme swaps gloutons** (AC: 1)
  - [ ] Section "Heuristique Amélioration Locale":
    - Principe greedy local search
    - Fonction evaluate_swap (O(x))
    - Boucle itérative jusqu'au plateau local
    - Garantie non-dégradation
    - Limitation optimum local (pas global)

- [ ] **Task 3: Documenter critères d'arrêt** (AC: 1)
  - [ ] Section "Critères d'Arrêt":
    - Plateau local: aucun swap bénéfique trouvé
    - Max iterations: limite supérieure sécurité (default 100)
    - Performance vs qualité trade-off

- [ ] **Task 4: Documenter trade-offs** (AC: 1)
  - [ ] Section "Trade-offs Équité vs Répétitions":
    - Phase 2 minimise répétitions (peut créer inéquité)
    - Phase 3 garantit équité (peut augmenter légèrement répétitions)
    - Priorité: Équité > Répétitions minimales
    - FR6 (équité ±1) est garantie stricte

- [ ] **Task 5: Mettre à jour README.md** (AC: 2)
  - [ ] Ajouter section "Comment ça marche ?"
  - [ ] Schéma textuel:
    ```
    [Config] → Phase 1: Baseline → Phase 2: Amélioration → Phase 3: Équité → [Planning + Métriques]
              (Round-Robin)       (Swaps Gloutons)       (Garantie ±1)
    ```
  - [ ] Exemple métriques avant/après:
    ```
    Baseline (N=30):
      • Paires uniques: 145
      • Répétitions: 20
      • Équité (écart): 3

    Optimisé (N=30):
      • Paires uniques: 145
      • Répétitions: 7 (-65%)
      • Équité (écart): 1 ✓
    ```

- [ ] **Task 6: Créer example advanced_usage.py** (AC: 3, 4)
  - [ ] Créer `examples/advanced_usage.py`
  - [ ] Comparer baseline vs optimisé:
    ```python
    from src.planner import generate_optimized_planning
    from src.baseline import generate_baseline
    from src.metrics import compute_metrics

    config = PlanningConfig(N=30, X=5, x=6, S=6)

    # Baseline seul
    print("=== BASELINE (Phase 1 uniquement) ===")
    baseline = generate_baseline(config, seed=42)
    metrics_baseline = compute_metrics(baseline, config)
    print(f"Répétitions: {metrics_baseline.total_repeat_pairs}")
    print(f"Équité (écart): {metrics_baseline.equity_gap}")

    # Optimisé (3 phases)
    print("\n=== OPTIMISÉ (Pipeline 3 Phases) ===")
    planning, metrics = generate_optimized_planning(config, seed=42)
    print(f"Répétitions: {metrics.total_repeat_pairs}")
    print(f"Équité (écart): {metrics.equity_gap}")

    # Comparaison
    reduction = (metrics_baseline.total_repeat_pairs - metrics.total_repeat_pairs) / metrics_baseline.total_repeat_pairs
    print(f"\nAmélioration: {reduction*100:.1f}% réduction répétitions")
    ```
  - [ ] Ajouter commentaires explicatifs français

- [ ] **Task 7: Vérifier docstrings optimizer.py** (AC: 5)
  - [ ] Vérifier evaluate_swap docstring: complexité O(x), garanties immutabilité
  - [ ] Vérifier improve_planning docstring: complexité O(iter×S×X²×x²), garantie plateau local
  - [ ] Vérifier enforce_equity docstring: complexité O(S×N), garantie FR6

- [ ] **Task 8: Vérifier docstrings planner.py** (AC: 5)
  - [ ] Vérifier generate_optimized_planning docstring:
    - Pipeline 3 phases
    - Performance attendue (N=100 <2s, N=300 <5s)
    - Garanties: FR6 équité ±1, planning valide
    - Gestion configs impossibles

- [ ] **Task 9: Tester example advanced_usage.py** (AC: 4)
  - [ ] Exécuter: `python examples/advanced_usage.py`
  - [ ] Vérifier output lisible et cohérent
  - [ ] Vérifier amélioration visible (réduction répétitions)

- [ ] **Task 10: Créer QA Gate YAML**
  - [ ] Créer `docs/qa/gates/2.7-documentation-optimization.yml`

---

## Dev Notes

### Dépendance

**Epic 1 complet + Stories 2.1-2.6 complètes:**
- Pipeline 3 phases implémenté et testé

Cette story **documente** le système d'optimisation pour utilisateurs techniques.

### Documentation Architecture - Contenu Clé

**Pipeline 3 Phases:**
```
Phase 1: BASELINE (Round-Robin)
├─ Algorithme: Rotation systématique avec stride
├─ Complexité: O(N × S)
├─ Sortie: Planning valide, répétitions possibles
└─ Performance: <100ms pour N=1000

Phase 2: AMÉLIORATION LOCALE (Greedy Swaps)
├─ Algorithme: Recherche locale gloutonne
├─ Primitive: evaluate_swap O(x)
├─ Itérations: jusqu'à plateau local (ou max_iterations)
├─ Complexité: O(iter × S × X² × x²)
├─ Sortie: Répétitions minimisées (optimum local)
└─ Performance: ~1-3s pour N=100

Phase 3: ENFORCEMENT ÉQUITÉ (Targeted Swaps)
├─ Algorithme: Swaps ciblés over-exposed ↔ under-exposed
├─ Complexité: O(S × N)
├─ Sortie: Garantie max_unique - min_unique ≤ 1 (FR6)
└─ Performance: <1s pour N=300
```

### Exemple Métriques Avant/Après

**Configuration:** N=30, X=5, x=6, S=6

| Métrique | Baseline | Optimisé | Amélioration |
|----------|----------|----------|--------------|
| Paires uniques | 145 | 145 | - |
| Répétitions | 20 | 7 | **-65%** |
| Écart équité | 3 | 1 | **-67%** |
| Min unique/personne | 8 | 10 | +25% |
| Max unique/personne | 11 | 11 | - |

---

## Testing

### Validation Documentation

**1. Example s'exécute**
```bash
python examples/advanced_usage.py

# Output attendu:
=== BASELINE (Phase 1 uniquement) ===
Répétitions: 20
Équité (écart): 3

=== OPTIMISÉ (Pipeline 3 Phases) ===
Répétitions: 7
Équité (écart): 1

Amélioration: 65.0% réduction répétitions
```

**2. Architecture complète**
- Vérifier section Pipeline 3 Phases présente
- Vérifier explication heuristique swaps gloutons
- Vérifier critères d'arrêt documentés

**3. README à jour**
- Section "Comment ça marche ?" présente
- Schéma pipeline visible
- Exemple métriques avant/après

---

## QA Gate

**Fichier:** `docs/qa/gates/2.7-documentation-optimization.yml`

```yaml
story: 2.7-documentation-optimization
checks:
  - name: Example Execution
    command: python examples/advanced_usage.py
    expected: Output shows baseline vs optimized comparison

  - name: README Updated
    command: grep -q "Comment ça marche" README.md && echo "✓ Section présente"
    expected: "Comment ça marche" section present

  - name: Architecture Updated
    command: grep -q "Pipeline Hybride 3 Phases" docs/architecture/vue-densemble-de-larchitecture.md && echo "✓ Section présente"
    expected: Pipeline 3 phases documented

  - name: Docstrings Complete
    command: grep -A 10 "def generate_optimized_planning" src/planner.py | grep -q "Complexity"
    expected: Complexity documented in docstrings

  - name: Code Formatting
    command: black --check examples/advanced_usage.py
    expected: Example formatted
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

**Definition of Done:**
- [ ] Architecture complétée: Pipeline 3 phases, heuristique, critères, trade-offs
- [ ] README.md mis à jour: section "Comment ça marche ?", schéma, exemple métriques
- [ ] `examples/advanced_usage.py` créé et fonctionnel
- [ ] Exemple s'exécute sans erreur, output lisible
- [ ] Docstrings optimizer.py: complexité et garanties documentées
- [ ] Docstrings planner.py: performance et garanties documentées
- [ ] QA Gate YAML créé
- [ ] **Granularité:** 1 story = 1 PR (documentation Epic 2)
