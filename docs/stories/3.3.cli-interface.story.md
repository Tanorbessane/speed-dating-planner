# Story 3.3: Implémenter l'Interface CLI Complète

## Status

**Draft**

---

## Story

**As a** utilisateur,
**I want** une interface en ligne de commande intuitive avec workflow complet,
**so that** je peux facilement générer et exporter des plannings sans écrire de code Python.

---

## Acceptance Criteria

1. Un module `src/cli.py` contient fonctions `parse_args()` et `main()`
2. Arguments CLI obligatoires (NFR7) :
   - `--participants N` ou `-n N`
   - `--tables X` ou `-t X`
   - `--capacity x` ou `-c x`
   - `--sessions S` ou `-s S`
3. Arguments CLI optionnels :
   - `--output fichier` ou `-o fichier` (défaut : `planning.csv`)
   - `--format {csv|json}` ou `-f {csv|json}` (défaut : `csv`)
   - `--seed SEED` (défaut : `42`)
   - `--verbose` ou `-v` (active logging DEBUG)
4. `main()` orchestre flux complet :
   - Parsing arguments
   - Configuration logging
   - Validation config
   - Génération planning optimisé
   - Affichage métriques console
   - Export fichier
5. Gestion d'erreurs avec exit codes :
   - Exit code 0: succès
   - Exit code 1: configuration invalide
   - Exit code 2: erreur I/O (export)
   - Exit code 3: erreur inattendue
6. Messages en français (NFR10)
7. Les tests vérifient exécution end-to-end réussie

---

## Tasks / Subtasks

- [ ] **Task 1: Créer module cli.py** (AC: 1)
  - [ ] Créer `src/cli.py`
  - [ ] Importer: argparse, logging, sys
  - [ ] Importer: PlanningConfig, InvalidConfigurationError
  - [ ] Importer: generate_optimized_planning
  - [ ] Importer: export_to_csv, export_to_json

- [ ] **Task 2: Implémenter parse_args()** (AC: 2, 3)
  - [ ] Créer ArgumentParser avec description française
  - [ ] Ajouter arguments obligatoires:
    ```python
    parser.add_argument('-n', '--participants', type=int, required=True,
                       help="Nombre total de participants (N ≥ 2)")
    parser.add_argument('-t', '--tables', type=int, required=True,
                       help="Nombre de tables disponibles (X ≥ 1)")
    parser.add_argument('-c', '--capacity', type=int, required=True,
                       help="Capacité maximale par table (x ≥ 2)")
    parser.add_argument('-s', '--sessions', type=int, required=True,
                       help="Nombre de sessions (S ≥ 1)")
    ```
  - [ ] Ajouter arguments optionnels:
    ```python
    parser.add_argument('-o', '--output', type=str, default='planning.csv',
                       help="Fichier de sortie (défaut: planning.csv)")
    parser.add_argument('-f', '--format', choices=['csv', 'json'], default='csv',
                       help="Format d'export (défaut: csv)")
    parser.add_argument('--seed', type=int, default=42,
                       help="Seed aléatoire pour reproductibilité (défaut: 42)")
    parser.add_argument('-v', '--verbose', action='store_true',
                       help="Mode verbeux (logs DEBUG)")
    ```
  - [ ] Retourner args parsed

- [ ] **Task 3: Implémenter main()** (AC: 4, 5, 6)
  - [ ] Fonction main() -> int (exit code)
  - [ ] Appeler parse_args()
  - [ ] Configurer logging:
    ```python
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=log_level, format='%(levelname)s: %(message)s')
    ```
  - [ ] Try/except global avec gestion erreurs:
    ```python
    try:
        # Workflow principal
    except InvalidConfigurationError as e:
        print(f"\n❌ ERREUR DE CONFIGURATION : {e}\n", file=sys.stderr)
        return 1
    except IOError as e:
        print(f"\n❌ ERREUR D'EXPORT : {e}\n", file=sys.stderr)
        return 2
    except Exception as e:
        if args.verbose:
            import traceback
            traceback.print_exc()
        else:
            print(f"\n❌ ERREUR INATTENDUE : {e}\n", file=sys.stderr)
        return 3
    ```

- [ ] **Task 4: Implémenter workflow principal** (AC: 4)
  - [ ] Créer PlanningConfig depuis args
  - [ ] Générer planning: `planning, metrics = generate_optimized_planning(config, seed=args.seed)`
  - [ ] Afficher métriques console:
    ```python
    print("\n" + "="*70)
    print("PLANNING GÉNÉRÉ AVEC SUCCÈS")
    print("="*70)
    print(f"Configuration : {config.N} participants, {config.X} tables, capacité {config.x}, {config.S} sessions")
    print(f"\nMétriques de qualité :")
    print(f"  • Paires uniques créées    : {metrics.total_unique_pairs}")
    print(f"  • Répétitions              : {metrics.total_repeat_pairs}")
    print(f"  • Rencontres par personne  : min={metrics.min_unique}, max={metrics.max_unique}, moyenne={metrics.mean_unique:.1f}")
    print(f"  • Équité (écart max-min)   : {metrics.equity_gap} ✓")
    print("="*70 + "\n")
    ```
  - [ ] Export selon format:
    ```python
    if args.format == 'csv':
        export_to_csv(planning, config, args.output)
    else:
        export_to_json(planning, config, args.output)
    ```
  - [ ] Message succès:
    ```python
    print(f"✓ Planning exporté vers : {args.output}\n")
    ```
  - [ ] Return 0

- [ ] **Task 5: Ajouter point d'entrée __main__** (AC: 4)
  - [ ] À la fin de cli.py:
    ```python
    if __name__ == '__main__':
        sys.exit(main())
    ```

- [ ] **Task 6: Créer tests test_cli.py** (AC: 7)
  - [ ] Créer `tests/test_cli.py`
  - [ ] Importer: pytest, subprocess, tempfile

- [ ] **Task 7: Test CLI exécution end-to-end** (AC: 7)
  - [ ] Exécuter via subprocess:
    ```python
    result = subprocess.run([
        'python', '-m', 'src.cli',
        '-n', '30', '-t', '5', '-c', '6', '-s', '6',
        '-o', temp_output
    ], capture_output=True, text=True)
    ```
  - [ ] Vérifier exit code 0
  - [ ] Vérifier fichier créé
  - [ ] Vérifier output contient "PLANNING GÉNÉRÉ AVEC SUCCÈS"

- [ ] **Task 8: Test erreur configuration invalide** (AC: 5)
  - [ ] Exécuter avec config invalide (N=50, X=5, x=8)
  - [ ] Vérifier exit code 1
  - [ ] Vérifier stderr contient "ERREUR DE CONFIGURATION"

- [ ] **Task 9: Test formats CSV et JSON** (AC: 3, 4)
  - [ ] Test avec --format csv: vérifier fichier .csv créé
  - [ ] Test avec --format json: vérifier fichier .json créé

- [ ] **Task 10: Test mode verbose** (AC: 3)
  - [ ] Exécuter avec --verbose
  - [ ] Vérifier output contient logs DEBUG (plus détaillés)

- [ ] **Task 11: Créer QA Gate YAML**
  - [ ] Créer `docs/qa/gates/3.3-cli-interface.yml`

---

## Dev Notes

### Dépendance

**Epic 1-2 + Stories 3.1-3.2:**
- Pipeline complet
- Exporteurs CSV/JSON

Cette story implémente **NFR7** (CLI) et finalise le produit utilisable.

### Implémentation CLI - Code Complet

[Source: docs/architecture/interfaces-entre-modules.md#3.8]

Code complet dans architecture section 3.8 (module cli.py).

### Messages Français (NFR10)

**Tous messages utilisateur en français:**
- Descriptions arguments: "Nombre total de participants..."
- Messages succès: "Planning généré avec succès"
- Messages erreur: "ERREUR DE CONFIGURATION : ..."
- Labels métriques: "Paires uniques créées", "Équité (écart max-min)"

### Exit Codes Standards

- **0**: Succès
- **1**: Configuration invalide (erreur utilisateur)
- **2**: Erreur I/O (problème système)
- **3**: Erreur inattendue (bug logiciel)

### Exemple Utilisation CLI

```bash
# Minimal
python -m src.cli -n 30 -t 5 -c 6 -s 6

# Complet
python -m src.cli \
  --participants 100 \
  --tables 20 \
  --capacity 5 \
  --sessions 10 \
  --output mon_planning.json \
  --format json \
  --seed 42 \
  --verbose
```

---

## Testing

### Test End-to-End

```python
import subprocess
import tempfile

def test_cli_end_to_end_success():
    with tempfile.NamedTemporaryFile(suffix='.csv', delete=False) as f:
        output_file = f.name

    result = subprocess.run([
        'python', '-m', 'src.cli',
        '-n', '30', '-t', '5', '-c', '6', '-s', '6',
        '-o', output_file,
        '--seed', '42'
    ], capture_output=True, text=True)

    assert result.returncode == 0
    assert "PLANNING GÉNÉRÉ AVEC SUCCÈS" in result.stdout
    assert Path(output_file).exists()

    # Vérifier contenu CSV
    with open(output_file) as f:
        lines = f.readlines()
    assert len(lines) > 1  # Header + data
```

---

## QA Gate

**Fichier:** `docs/qa/gates/3.3-cli-interface.yml`

```yaml
story: 3.3-cli-interface
checks:
  - name: CLI End-to-End Success
    command: python -m src.cli -n 30 -t 5 -c 6 -s 6 -o /tmp/test.csv
    expected: Exit code 0, file created

  - name: CLI Invalid Config
    command: python -m src.cli -n 50 -t 5 -c 8 -s 3 -o /tmp/test.csv || echo "Exit $?"
    expected: Exit code 1

  - name: CLI Help French
    command: python -m src.cli --help | grep "participants"
    expected: French description present

  - name: Unit Tests
    command: pytest tests/test_cli.py -v
    expected: All tests pass

  - name: Type Checking
    command: mypy src/cli.py --strict
    expected: No errors
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

**Definition of Done:**
- [ ] `src/cli.py` créé avec parse_args() et main()
- [ ] Arguments obligatoires: -n, -t, -c, -s (NFR7)
- [ ] Arguments optionnels: -o, -f, --seed, -v
- [ ] Workflow complet: parsing → génération → affichage → export
- [ ] Gestion erreurs: exit codes 0/1/2/3
- [ ] Messages français (NFR10)
- [ ] Tests end-to-end CLI
- [ ] Test erreur config invalide (exit code 1)
- [ ] Test formats CSV et JSON
- [ ] `mypy --strict` passe
- [ ] QA Gate YAML créé
- [ ] **Granularité:** 1 story = 1 PR (CLI complète)
