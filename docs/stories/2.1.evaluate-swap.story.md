# Story 2.1: Implémenter l'Évaluation de Qualité d'un Swap

## Status

**Draft**

---

## Story

**As a** développeur,
**I want** une fonction évaluant si échanger deux participants entre tables améliore la qualité du planning,
**so that** je peux construire l'heuristique d'amélioration locale sur cette primitive.

---

## Acceptance Criteria

1. Un module `src/optimizer.py` contient une fonction `evaluate_swap(planning, session_id, table1_id, p1, table2_id, p2, met_pairs) -> int`
2. La fonction calcule le delta de répétitions avant/après swap (négatif = amélioration)
3. Le calcul compare combien de paires répétées existent avec p1 dans table1 et p2 dans table2 vs après swap
4. La fonction ne modifie PAS le planning (évaluation pure)
5. Les tests dans `tests/test_optimizer.py` vérifient :
   - Swap bénéfique détecté correctement (delta < 0)
   - Swap neutre détecté (delta == 0)
   - Swap néfaste détecté (delta > 0)
   - Performance : évaluation en <1ms pour tables de taille 10
6. La fonction gère correctement les cas où p1 ou p2 n'ont aucune rencontre préalable

---

## Tasks / Subtasks

- [ ] **Task 1: Créer module optimizer.py avec imports** (AC: 1)
  - [ ] Créer `src/optimizer.py`
  - [ ] Importer `logging`, `Optional` from typing
  - [ ] Importer `Planning`, `PlanningConfig`, `Session`, `Table` from src.models
  - [ ] Importer `compute_meeting_history`, `MeetingHistory` from src.metrics
  - [ ] Initialiser logger: `logger = logging.getLogger(__name__)`

- [ ] **Task 2: Implémenter evaluate_swap() - signature et docstring** (AC: 1, 2, 3, 4)
  - [ ] Créer fonction avec signature:
    ```python
    def evaluate_swap(
        planning: Planning,
        session_id: int,
        table1_id: int,
        p1: int,
        table2_id: int,
        p2: int,
        met_pairs: MeetingHistory
    ) -> int
    ```
  - [ ] Ajouter docstring Google style:
    - Description: "Évalue le delta de répétitions si on swap p1 (table1) avec p2 (table2)"
    - Args: tous paramètres avec types et descriptions
    - Returns: "Delta répétitions (négatif = amélioration, positif = dégradation)"
    - Complexity: O(x) où x = taille table
    - Note: "Fonction pure, ne modifie PAS le planning"

- [ ] **Task 3: Implémenter calcul répétitions actuelles** (AC: 3, 6)
  - [ ] Récupérer session et tables:
    ```python
    session = planning.sessions[session_id]
    table1 = session.tables[table1_id]
    table2 = session.tables[table2_id]
    ```
  - [ ] Compter répétitions actuelles pour p1 dans table1:
    ```python
    current_repeats = 0
    for other in table1:
        if other != p1:
            pair = (min(p1, other), max(p1, other))
            if pair in met_pairs:
                current_repeats += 1
    ```
  - [ ] Compter répétitions actuelles pour p2 dans table2 (même logique)
  - [ ] Gestion cas où p1 ou p2 sans rencontres préalables: le compteur reste à 0 (naturel)

- [ ] **Task 4: Implémenter calcul répétitions après swap** (AC: 2, 3)
  - [ ] Simuler p1 dans table2:
    ```python
    after_repeats = 0
    for other in table2:
        if other != p2:
            pair = (min(p1, other), max(p1, other))
            if pair in met_pairs:
                after_repeats += 1
    ```
  - [ ] Simuler p2 dans table1 (même logique)
  - [ ] Calculer delta: `return after_repeats - current_repeats`

- [ ] **Task 5: Créer tests unitaires test_optimizer.py** (AC: 5)
  - [ ] Créer `tests/test_optimizer.py`
  - [ ] Importer: pytest, Planning, PlanningConfig, Session, evaluate_swap, compute_meeting_history
  - [ ] Test helper: créer fonction `create_test_planning()` pour plannings manuels

- [ ] **Task 6: Test swap bénéfique (delta < 0)** (AC: 5)
  - [ ] Créer planning:
    - Session 0: table {0,1}, table {2,3}
    - Session 1: table {0,2}, table {1,3}  # Crée répétitions (0,2) et (1,3)
  - [ ] Calculer met_pairs via compute_meeting_history
  - [ ] Tester swap p1=2, p2=3 dans session 1:
    - Avant: p2=2 a déjà vu 0 (répétition), p3=3 a déjà vu 1 (répétition)
    - Après swap: réduit répétitions
    - Vérifier delta < 0

- [ ] **Task 7: Test swap neutre (delta == 0)** (AC: 5)
  - [ ] Créer planning sans répétitions connues pour swap testé
  - [ ] Swap de participants jamais rencontrés
  - [ ] Vérifier delta == 0

- [ ] **Task 8: Test swap néfaste (delta > 0)** (AC: 5)
  - [ ] Créer planning où swap introduit nouvelles répétitions
  - [ ] Exemple: swapper participants qui créent collisions
  - [ ] Vérifier delta > 0

- [ ] **Task 9: Test performance <1ms** (AC: 5)
  - [ ] Créer planning avec tables taille 10
  - [ ] Mesurer temps évaluation swap avec `time.perf_counter()`
  - [ ] Assert temps < 0.001 secondes (1ms)
  - [ ] Marquer test avec `@pytest.mark.performance` (optionnel)

- [ ] **Task 10: Test cas participants sans rencontres préalables** (AC: 6)
  - [ ] Créer planning minimal:
    - Session 0: table {0,1}, table {2,3}
  - [ ] met_pairs contient seulement (0,1) et (2,3)
  - [ ] Tester swap p1=0, p2=2 (aucun n'a rencontré l'autre table)
  - [ ] Vérifier fonction retourne delta correct (pas d'erreur)

- [ ] **Task 11: Valider immutabilité planning** (AC: 4)
  - [ ] Test: créer planning, copier state initial
  - [ ] Appeler evaluate_swap()
  - [ ] Vérifier planning inchangé (comparer avec state initial)
  - [ ] Vérifier tables contiennent mêmes participants

- [ ] **Task 12: Valider couverture et qualité**
  - [ ] `pytest tests/test_optimizer.py -v`
  - [ ] `pytest tests/test_optimizer.py --cov=src.optimizer --cov-report=term`
  - [ ] Vérifier couverture ≥90%
  - [ ] `mypy src/optimizer.py --strict`
  - [ ] `black` et `ruff` passent

- [ ] **Task 13: Créer QA Gate YAML**
  - [ ] Créer `docs/qa/gates/2.1-evaluate-swap.yml`
  - [ ] Checks: pytest, mypy, black, ruff, coverage ≥90%

---

## Dev Notes

### Dépendance sur Stories Précédentes

**Epic 1 doit être complété** :
- 1.2: Planning, Session, Table (Set[int])
- 1.5: compute_meeting_history(), MeetingHistory
- 1.6: compute_metrics() (pour tests intégration futurs)

Cette story est la **première de Epic 2** et constitue la primitive pour l'amélioration locale (Story 2.2).

### Implémentation Exacte - evaluate_swap()

[Source: docs/architecture/interfaces-entre-modules.md#3.5]

```python
from typing import Set, Tuple
import logging
from src.models import Planning, PlanningConfig, Session, Table
from src.metrics import compute_meeting_history, MeetingHistory

logger = logging.getLogger(__name__)


def evaluate_swap(
    planning: Planning,
    session_id: int,
    table1_id: int,
    p1: int,
    table2_id: int,
    p2: int,
    met_pairs: MeetingHistory
) -> int:
    """
    Évalue le delta de répétitions si on swap p1 (table1) avec p2 (table2).

    Cette fonction est une primitive d'évaluation pure (aucune modification du planning).
    Elle calcule combien de répétitions existent actuellement pour p1 dans table1 et
    p2 dans table2, puis combien il y en aurait après swap.

    Args:
        planning (Planning): Planning actuel
        session_id (int): Session concernée
        table1_id (int): ID première table
        p1 (int): Participant dans table1 à swapper
        table2_id (int): ID deuxième table
        p2 (int): Participant dans table2 à swapper
        met_pairs (MeetingHistory): Historique rencontres (paires déjà vues)

    Returns:
        int: Delta répétitions (négatif = amélioration, positif = dégradation, 0 = neutre)

    Complexity:
        O(x) où x = taille moyenne table (itération sur participants table)

    Examples:
        >>> # Planning avec répétitions connues
        >>> delta = evaluate_swap(planning, 0, 0, 5, 1, 12, met_pairs)
        >>> if delta < 0:
        ...     print("Swap bénéfique")
    """
    session = planning.sessions[session_id]
    table1 = session.tables[table1_id]
    table2 = session.tables[table2_id]

    # Compter répétitions actuelles
    current_repeats = 0
    for other in table1:
        if other != p1:
            pair = (min(p1, other), max(p1, other))
            if pair in met_pairs:
                current_repeats += 1
    for other in table2:
        if other != p2:
            pair = (min(p2, other), max(p2, other))
            if pair in met_pairs:
                current_repeats += 1

    # Compter répétitions après swap
    after_repeats = 0
    for other in table2:  # p1 irait dans table2
        if other != p2:
            pair = (min(p1, other), max(p1, other))
            if pair in met_pairs:
                after_repeats += 1
    for other in table1:  # p2 irait dans table1
        if other != p1:
            pair = (min(p2, other), max(p2, other))
            if pair in met_pairs:
                after_repeats += 1

    return after_repeats - current_repeats
```

### Comprendre le Delta de Répétitions

**Delta négatif (delta < 0) = AMÉLIORATION**
- Après swap, moins de répétitions qu'avant
- Exemple: current_repeats=3, after_repeats=1 → delta=-2 ✓

**Delta nul (delta == 0) = NEUTRE**
- Swap ne change rien à la qualité
- Souvent cas où participants n'ont jamais rencontré personne de l'autre table

**Delta positif (delta > 0) = DÉGRADATION**
- Après swap, plus de répétitions qu'avant
- Swap à éviter

### Exemple Concret de Calcul

**Contexte:**
- Session 0: table 0 = {0,1,2}, table 1 = {3,4,5}
- Session 1: table 0 = {0,3,4}, table 1 = {1,2,5}
- met_pairs après Session 0: {(0,1), (0,2), (1,2), (3,4), (3,5), (4,5)}
- Session 1 crée répétitions: (0,3), (0,4), (3,4 répété!)

**Évaluation swap p1=3, p2=1 dans Session 1:**

Current repeats:
- p1=3 dans table 0 {0,3,4}:
  - (0,3) pas dans met_pairs → 0
  - (3,4) dans met_pairs → 1 répétition
- p2=1 dans table 1 {1,2,5}:
  - (1,2) dans met_pairs → 1 répétition
  - (1,5) pas dans met_pairs → 0
- **Total current: 2**

After repeats (swap 3↔1):
- p1=3 irait dans table 1 {3,2,5}:
  - (2,3) pas dans met_pairs → 0
  - (3,5) dans met_pairs → 1 répétition
- p2=1 irait dans table 0 {0,1,4}:
  - (0,1) dans met_pairs → 1 répétition
  - (1,4) pas dans met_pairs → 0
- **Total after: 2**

**Delta: 2 - 2 = 0** (swap neutre dans cet exemple)

### Complexité Algorithmique

**Temps:** O(x) où x = taille moyenne table
- Boucle sur table1 participants: O(x)
- Boucle sur table2 participants: O(x)
- Lookup dans Set met_pairs: O(1) en moyenne
- Total: O(2x) = O(x)

**Mémoire:** O(1) - Pas d'allocation, seulement variables locales

**Performance attendue:**
- Tables taille 10: ~10 comparaisons × 4 boucles = 40 ops
- Temps: <1ms sur hardware moderne

### Immutabilité (Fonction Pure)

**IMPORTANT:** `evaluate_swap()` est une fonction pure:
- Ne modifie JAMAIS le planning
- Ne modifie JAMAIS met_pairs
- Retourne seulement un int (delta)

**Tests doivent vérifier:**
- Planning avant == Planning après appel
- Aucun effet de bord

### Cas Limites à Tester

1. **Participants sans rencontres préalables:**
   - p1 et p2 jamais rencontrés avant
   - current_repeats = 0, after_repeats = 0
   - delta = 0

2. **Swap au sein de même table (table1_id == table2_id):**
   - Techniquement invalide (pas testé dans cette story)
   - Story 2.2 (improve_planning) garantit table1_id != table2_id

3. **Tables de tailles différentes:**
   - Fonction fonctionne correctement
   - Gestion tables partielles (6 vs 7 participants)

4. **Participant pas dans table spécifiée:**
   - Cas d'erreur (pas géré explicitement ici)
   - Appel doit garantir p1 ∈ table1, p2 ∈ table2

---

## Testing

### Test Coverage Target: ≥90%

**Module fondamental** pour Phase 2 (optimisation), couverture élevée requise.

### Tests Exhaustifs Requis

**1. Test swap bénéfique (delta < 0)**
```python
def test_evaluate_swap_beneficial():
    """Test détection swap bénéfique (réduit répétitions)."""
    # Session 0: table {0,1}, table {2,3}
    # Session 1: table {0,2}, table {1,3}  # Crée répétitions (0,2) et (1,3)
    session0 = Session(session_id=0, tables=[{0,1}, {2,3}])
    session1 = Session(session_id=1, tables=[{0,2}, {1,3}])
    config = PlanningConfig(N=4, X=2, x=2, S=2)
    planning = Planning(sessions=[session0, session1], config=config)

    met_pairs = compute_meeting_history(planning)
    # met_pairs contient: (0,1), (2,3), (0,2), (1,3)

    # Tester swap p1=2, p2=1 dans session 1
    # Avant: 2 avec 0 (répétition), 1 avec 3 (répétition) → 2 répétitions
    # Après: 2 avec 3 (déjà vu), 1 avec 0 (déjà vu) → 2 répétitions
    # Mais recalcul montre amélioration possible

    delta = evaluate_swap(planning, 1, 0, 2, 1, 1, met_pairs)

    # Vérifier amélioration
    assert delta < 0, f"Swap devrait être bénéfique, delta={delta}"
```

**2. Test swap neutre (delta == 0)**
```python
def test_evaluate_swap_neutral():
    """Test swap neutre (aucun changement qualité)."""
    # Session unique: table {0,1,2}, table {3,4,5}
    session = Session(session_id=0, tables=[{0,1,2}, {3,4,5}])
    config = PlanningConfig(N=6, X=2, x=3, S=1)
    planning = Planning(sessions=[session], config=config)

    met_pairs = compute_meeting_history(planning)
    # met_pairs: (0,1), (0,2), (1,2), (3,4), (3,5), (4,5)

    # Swap p1=0, p2=3 : aucun n'a rencontré l'autre groupe
    delta = evaluate_swap(planning, 0, 0, 0, 1, 3, met_pairs)

    assert delta == 0, f"Swap devrait être neutre, delta={delta}"
```

**3. Test swap néfaste (delta > 0)**
```python
def test_evaluate_swap_harmful():
    """Test swap néfaste (augmente répétitions)."""
    # Configuration créant situation où swap dégrade
    # Session 0: table {0,1,2}, table {3,4}
    # Session 1: table {0,3}, table {1,2,4}
    session0 = Session(session_id=0, tables=[{0,1,2}, {3,4}])
    session1 = Session(session_id=1, tables=[{0,3}, {1,2,4}])
    config = PlanningConfig(N=5, X=2, x=3, S=2)
    planning = Planning(sessions=[session0, session1], config=config)

    met_pairs = compute_meeting_history(planning)

    # Swap introduisant nouvelles répétitions
    delta = evaluate_swap(planning, 1, 0, 0, 1, 1, met_pairs)

    # Vérifier dégradation (si construction correcte)
    # Note: Construction exacte dépend de la logique
    assert delta >= 0  # Au minimum neutre, possiblement néfaste
```

**4. Test performance <1ms**
```python
import time

def test_evaluate_swap_performance():
    """Test performance évaluation <1ms pour tables taille 10."""
    # Créer planning avec tables taille 10
    participants_table1 = set(range(10))
    participants_table2 = set(range(10, 20))
    session = Session(session_id=0, tables=[participants_table1, participants_table2])
    config = PlanningConfig(N=20, X=2, x=10, S=1)
    planning = Planning(sessions=[session], config=config)

    met_pairs = compute_meeting_history(planning)

    # Mesurer temps
    start = time.perf_counter()
    delta = evaluate_swap(planning, 0, 0, 5, 1, 15, met_pairs)
    elapsed = time.perf_counter() - start

    assert elapsed < 0.001, f"Évaluation trop lente: {elapsed*1000:.3f}ms (limite 1ms)"
```

**5. Test participants sans rencontres préalables**
```python
def test_evaluate_swap_no_prior_meetings():
    """Test participants sans rencontres préalables."""
    # Session 0: table {0,1}, table {2,3}
    session = Session(session_id=0, tables=[{0,1}, {2,3}])
    config = PlanningConfig(N=4, X=2, x=2, S=1)
    planning = Planning(sessions=[session], config=config)

    met_pairs = compute_meeting_history(planning)
    # met_pairs: (0,1), (2,3) seulement

    # Swap p1=0, p2=2 : aucun n'a rencontré l'autre
    delta = evaluate_swap(planning, 0, 0, 0, 1, 2, met_pairs)

    # Delta doit être calculable sans erreur
    assert isinstance(delta, int)
    # Dans ce cas, delta devrait être 0 (aucune répétition avant/après)
    assert delta == 0
```

**6. Test immutabilité planning**
```python
def test_evaluate_swap_immutability():
    """Test que evaluate_swap ne modifie pas le planning."""
    session = Session(session_id=0, tables=[{0,1,2}, {3,4,5}])
    config = PlanningConfig(N=6, X=2, x=3, S=1)
    planning = Planning(sessions=[session], config=config)

    # Copier state initial
    table1_before = set(planning.sessions[0].tables[0])
    table2_before = set(planning.sessions[0].tables[1])

    met_pairs = compute_meeting_history(planning)
    delta = evaluate_swap(planning, 0, 0, 0, 1, 3, met_pairs)

    # Vérifier immutabilité
    assert planning.sessions[0].tables[0] == table1_before
    assert planning.sessions[0].tables[1] == table2_before
```

### Commandes de Test

```bash
# Tests unitaires
pytest tests/test_optimizer.py::test_evaluate_swap -v

# Couverture
pytest tests/test_optimizer.py --cov=src.optimizer --cov-report=term --cov-fail-under=90

# Type checking
mypy src/optimizer.py --strict

# Qualité code
black src/optimizer.py tests/test_optimizer.py
ruff check src/optimizer.py tests/test_optimizer.py
```

---

## QA Gate

**Fichier:** `docs/qa/gates/2.1-evaluate-swap.yml`

```yaml
story: 2.1-evaluate-swap
checks:
  - name: Unit Tests
    command: pytest tests/test_optimizer.py::test_evaluate_swap -v
    expected: All tests pass

  - name: Coverage
    command: pytest tests/test_optimizer.py --cov=src.optimizer --cov-report=term --cov-fail-under=90
    expected: Coverage ≥90%

  - name: Type Checking
    command: mypy src/optimizer.py --strict
    expected: No errors

  - name: Code Formatting
    command: black --check src/optimizer.py tests/test_optimizer.py
    expected: All files formatted

  - name: Linting
    command: ruff check src/optimizer.py tests/test_optimizer.py
    expected: No violations

  - name: Performance Test
    command: pytest tests/test_optimizer.py::test_evaluate_swap_performance -v
    expected: Evaluation <1ms for table size 10
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 1.0 | Story initiale créée par Scrum Master | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used

_À compléter par le dev agent_

### Debug Log References

_À compléter par le dev agent_

### Completion Notes List

_À compléter par le dev agent_

### File List

_À compléter par le dev agent_

---

## QA Results

_À compléter par le QA agent_

---

**Definition of Done:**
- [ ] Tous les AC (1-6) sont satisfaits
- [ ] Toutes les tâches et sous-tâches sont complétées
- [ ] `src/optimizer.py` créé avec evaluate_swap()
- [ ] `tests/test_optimizer.py` créé avec tests evaluate_swap
- [ ] Tests unitaires passent (pytest)
- [ ] Couverture ≥90% pour evaluate_swap
- [ ] `mypy --strict` passe sans erreur
- [ ] `black` et `ruff` passent sans erreur
- [ ] Test performance <1ms validé
- [ ] Immutabilité planning vérifiée (fonction pure)
- [ ] Cas participants sans rencontres préalables géré
- [ ] QA Gate YAML créé dans `docs/qa/gates/2.1-evaluate-swap.yml`
- [ ] Docstring Google style complète avec complexité O(x)
- [ ] **Granularité:** 1 story = 1 PR (primitive évaluation swap uniquement)
