# Story 4.2: Contraintes Groupes (Must Be Together / Must Be Separate)

**Epic**: 4 - Gestion Ã‰vÃ©nements RÃ©els
**Story ID**: 4.2
**Priority**: HIGH
**Status**: In Progress
**Estimation**: 4 days
**Depends on**: Story 4.1 (Import Participants)

---

## User Story

**As an** organisateur d'Ã©vÃ©nement,
**I want** dÃ©finir des contraintes de groupes (toujours ensemble / toujours sÃ©parÃ©s),
**So that** je peux gÃ©rer des couples, Ã©quipes, ou concurrents qui ne doivent pas se rencontrer.

---

## Acceptance Criteria

### Must Be Together (Groupes CohÃ©sifs)
1. âœ… Pouvoir crÃ©er des groupes "must be together" (ex: couple, Ã©quipe)
2. âœ… Membres d'un groupe cohÃ©sif sont TOUJOURS Ã  la mÃªme table dans chaque session
3. âœ… Baseline gÃ©nÃ¨re planning respectant contrainte cohÃ©sive dÃ¨s le dÃ©part
4. âœ… Optimizer ne casse JAMAIS les groupes cohÃ©sifs (hard constraint)
5. âœ… Un participant peut appartenir Ã  maximum 1 groupe cohÃ©sif
6. âœ… Validation : groupe cohÃ©sif ne dÃ©passe pas capacitÃ© table (size â‰¤ x)

### Must Be Separate (Groupes Exclusifs)
7. âœ… Pouvoir crÃ©er des groupes "must be separate" (ex: concurrents, ex-conjoints)
8. âœ… Membres de groupes exclusifs ne sont JAMAIS Ã  la mÃªme table
9. âœ… Baseline gÃ©nÃ¨re planning respectant contrainte exclusive dÃ¨s le dÃ©part
10. âœ… Optimizer ne met JAMAIS ensemble des membres de groupes exclusifs
11. âœ… Un participant peut appartenir Ã  plusieurs groupes exclusifs
12. âœ… Validation : pas de conflit (mÃªme participant dans 2 groupes cohÃ©sifs)

### Validation & Erreurs
13. âœ… DÃ©tection conflits impossibles (ex: groupe cohÃ©sif trop grand)
14. âœ… DÃ©tection conflits logiques (A et B cohÃ©sifs, mais dans groupes exclusifs diffÃ©rents)
15. âœ… Messages d'erreur explicites en franÃ§ais
16. âœ… Contraintes respectÃ©es avant optimisation (baseline valide)

### Interface Utilisateur
17. âœ… Page Streamlit pour dÃ©finir contraintes groupes
18. âœ… Ajout/suppression groupes cohÃ©sifs
19. âœ… Ajout/suppression groupes exclusifs
20. âœ… Preview participants par groupe
21. âœ… Rapport validation contraintes avant gÃ©nÃ©ration

---

## Technical Design

### Data Model

```python
# src/models.py - Ajout contraintes

from enum import Enum
from typing import List, Set

class GroupConstraintType(Enum):
    """Type de contrainte de groupe."""
    MUST_BE_TOGETHER = "must_be_together"  # CohÃ©sif (mÃªme table)
    MUST_BE_SEPARATE = "must_be_separate"  # Exclusif (tables diffÃ©rentes)

@dataclass
class GroupConstraint:
    """Contrainte de groupe pour participants.

    Attributes:
        name: Nom du groupe (ex: "Couple 1", "Concurrents A-B")
        constraint_type: Type de contrainte (together/separate)
        participant_ids: Set d'IDs participants concernÃ©s

    Invariants:
        - len(participant_ids) >= 2 (au moins 2 participants)
        - MUST_BE_TOGETHER : tous Ã  la mÃªme table toujours
        - MUST_BE_SEPARATE : jamais Ã  la mÃªme table
    """
    name: str
    constraint_type: GroupConstraintType
    participant_ids: Set[int]

    def __post_init__(self):
        if len(self.participant_ids) < 2:
            raise ValueError(f"Groupe '{self.name}' doit contenir au moins 2 participants")

@dataclass
class PlanningConstraints:
    """Ensemble de contraintes pour un planning.

    Attributes:
        cohesive_groups: Liste groupes "must be together"
        exclusive_groups: Liste groupes "must be separate"
    """
    cohesive_groups: List[GroupConstraint] = field(default_factory=list)
    exclusive_groups: List[GroupConstraint] = field(default_factory=list)

    def validate(self, config: PlanningConfig) -> List[str]:
        """Valide contraintes vs configuration.

        Returns:
            Liste messages erreur (vide si OK)
        """
        errors = []

        # Valider groupes cohÃ©sifs
        cohesive_participant_ids = set()
        for group in self.cohesive_groups:
            # VÃ©rifier taille groupe â‰¤ capacitÃ© table
            if len(group.participant_ids) > config.x:
                errors.append(
                    f"Groupe cohÃ©sif '{group.name}' ({len(group.participant_ids)} participants) "
                    f"dÃ©passe capacitÃ© table ({config.x})"
                )

            # VÃ©rifier pas de participant dans 2 groupes cohÃ©sifs
            overlap = cohesive_participant_ids & group.participant_ids
            if overlap:
                errors.append(
                    f"Participants {overlap} apparaissent dans plusieurs groupes cohÃ©sifs"
                )
            cohesive_participant_ids.update(group.participant_ids)

        # Valider groupes exclusifs
        for group in self.exclusive_groups:
            # VÃ©rifier cohÃ©rence avec groupes cohÃ©sifs
            for cohesive_group in self.cohesive_groups:
                # Si 2+ membres d'un groupe cohÃ©sif sont dans un groupe exclusif â†’ conflit
                overlap = group.participant_ids & cohesive_group.participant_ids
                if len(overlap) >= 2:
                    errors.append(
                        f"Conflit : {overlap} sont cohÃ©sifs ('{cohesive_group.name}') "
                        f"mais aussi exclusifs ('{group.name}')"
                    )

        return errors
```

### Baseline Modification (src/baseline.py)

```python
def generate_baseline(
    config: PlanningConfig,
    seed: int = 42,
    constraints: Optional[PlanningConstraints] = None,
) -> Planning:
    """GÃ©nÃ¨re baseline round-robin avec respect contraintes.

    Pipeline :
    1. Valider contraintes vs config
    2. CrÃ©er "super-participants" pour groupes cohÃ©sifs
    3. Round-robin avec stride coprime
    4. VÃ©rifier contraintes exclusives respectÃ©es (assertion)
    """

    # 1. Validation
    if constraints:
        errors = constraints.validate(config)
        if errors:
            raise InvalidConfigurationError(f"Contraintes invalides: {errors}")

    # 2. Groupes cohÃ©sifs â†’ super-participants
    # Exemple : [0,1,2,3,4] avec groupe {0,1} â†’ super_participants = [{0,1}, 2, 3, 4]
    super_participants = _create_super_participants(config.N, constraints)

    # 3. Round-robin modifiÃ©
    # Assignation tables en traitant super-participants comme unitÃ© atomique
    sessions = []
    for session_id in range(config.S):
        tables = _assign_tables_with_constraints(
            super_participants, config, session_id, constraints
        )
        sessions.append(Session(session_id, tables))

    # 4. VÃ©rification contraintes exclusives
    planning = Planning(sessions, config)
    _assert_exclusive_constraints(planning, constraints)

    return planning

def _create_super_participants(
    N: int, constraints: Optional[PlanningConstraints]
) -> List[Set[int]]:
    """CrÃ©e super-participants (groupes cohÃ©sifs = 1 unitÃ©).

    Example:
        N=5, cohesive_groups=[{0,1}, {3,4}]
        â†’ [{0,1}, {2}, {3,4}]
    """
    if not constraints or not constraints.cohesive_groups:
        return [{i} for i in range(N)]

    assigned = set()
    super_participants = []

    # Ajouter groupes cohÃ©sifs
    for group in constraints.cohesive_groups:
        super_participants.append(group.participant_ids)
        assigned.update(group.participant_ids)

    # Ajouter participants individuels
    for i in range(N):
        if i not in assigned:
            super_participants.append({i})

    return super_participants

def _assign_tables_with_constraints(
    super_participants: List[Set[int]],
    config: PlanningConfig,
    session_id: int,
    constraints: Optional[PlanningConstraints],
) -> List[Set[int]]:
    """Assigne super-participants aux tables avec contraintes exclusives.

    Strategy:
    - Round-robin standard pour super-participants
    - VÃ©rifier contraintes exclusives avant assignation
    - Si conflit â†’ skip et rÃ©assigner ailleurs
    """
    tables = [set() for _ in range(config.X)]

    # Round-robin avec vÃ©rification contraintes
    for idx, sp in enumerate(super_participants):
        table_id = (session_id + idx * stride) % config.X

        # VÃ©rifier contrainte exclusive
        if constraints and constraints.exclusive_groups:
            while _violates_exclusive_constraint(tables[table_id], sp, constraints):
                # Essayer table suivante
                table_id = (table_id + 1) % config.X

        # Assigner super-participant Ã  table
        tables[table_id].update(sp)

    return tables

def _violates_exclusive_constraint(
    table: Set[int], new_participants: Set[int], constraints: PlanningConstraints
) -> bool:
    """VÃ©rifie si ajouter new_participants Ã  table viole contrainte exclusive."""
    for group in constraints.exclusive_groups:
        # Si table contient dÃ©jÃ  un membre du groupe ET on ajoute un autre â†’ violation
        table_has_member = bool(table & group.participant_ids)
        new_has_member = bool(new_participants & group.participant_ids)

        if table_has_member and new_has_member:
            # VÃ©rifier que ce ne sont pas les mÃªmes (OK si mÃªme participant)
            if (table & group.participant_ids) != (new_participants & group.participant_ids):
                return True

    return False
```

### Optimizer Protection (src/improvement.py)

```python
def improve_planning(
    planning: Planning,
    config: PlanningConfig,
    max_iterations: int = 100,
    constraints: Optional[PlanningConstraints] = None,
) -> Planning:
    """AmÃ©liore planning avec protection contraintes hard.

    Modifications:
    - Avant chaque swap : vÃ©rifier que swap ne viole pas contraintes
    - Groupes cohÃ©sifs : membres jamais sÃ©parÃ©s
    - Groupes exclusifs : membres jamais rÃ©unis
    """

    for iteration in range(max_iterations):
        for session in planning.sessions:
            for table1_id in range(len(session.tables)):
                for table2_id in range(table1_id + 1, len(session.tables)):
                    # Essayer tous swaps possibles
                    for p1 in list(session.tables[table1_id]):
                        for p2 in list(session.tables[table2_id]):
                            # NOUVEAU : VÃ©rifier contraintes avant swap
                            if constraints and _swap_violates_constraints(
                                session, table1_id, p1, table2_id, p2, constraints
                            ):
                                continue  # Skip swap interdit

                            # Ã‰valuer et appliquer swap si bÃ©nÃ©fique
                            delta = evaluate_swap(...)
                            if delta < 0:
                                _apply_swap(session, table1_id, p1, table2_id, p2)

    return planning

def _swap_violates_constraints(
    session: Session,
    table1_id: int,
    p1: int,
    table2_id: int,
    p2: int,
    constraints: PlanningConstraints,
) -> bool:
    """VÃ©rifie si swap p1 â†” p2 viole contraintes hard.

    Returns:
        True si swap interdit, False si OK
    """
    # VÃ©rifier groupes cohÃ©sifs (membres doivent rester ensemble)
    for group in constraints.cohesive_groups:
        # Si p1 fait partie d'un groupe cohÃ©sif
        if p1 in group.participant_ids:
            # VÃ©rifier que tous les autres membres sont aussi Ã  table1
            other_members = group.participant_ids - {p1}
            if not other_members.issubset(session.tables[table1_id]):
                # Swap casserait le groupe â†’ interdit
                return True

        # MÃªme vÃ©rification pour p2
        if p2 in group.participant_ids:
            other_members = group.participant_ids - {p2}
            if not other_members.issubset(session.tables[table2_id]):
                return True

    # VÃ©rifier groupes exclusifs (membres ne doivent jamais Ãªtre ensemble)
    for group in constraints.exclusive_groups:
        # Simuler Ã©tat aprÃ¨s swap
        table1_after = (session.tables[table1_id] - {p1}) | {p2}
        table2_after = (session.tables[table2_id] - {p2}) | {p1}

        # VÃ©rifier table1 aprÃ¨s swap
        members_in_table1 = table1_after & group.participant_ids
        if len(members_in_table1) >= 2:
            # 2+ membres du groupe exclusif ensemble â†’ interdit
            return True

        # VÃ©rifier table2 aprÃ¨s swap
        members_in_table2 = table2_after & group.participant_ids
        if len(members_in_table2) >= 2:
            return True

    return False
```

### Interface Streamlit (app/pages/6_ğŸ”—_Contraintes.py)

```python
"""Page Contraintes - Groupes cohÃ©sifs et exclusifs."""

import streamlit as st
from src.models import GroupConstraint, GroupConstraintType, PlanningConstraints

st.set_page_config(page_title="Contraintes", page_icon="ğŸ”—", layout="wide")
st.title("ğŸ”— Contraintes de Groupes")

# VÃ©rifier participants importÃ©s
if "participants" not in st.session_state or st.session_state.participants is None:
    st.warning("âš ï¸ Importez d'abord des participants (page ğŸ‘¥ Participants)")
    st.stop()

participants_df = st.session_state.participants

# Initialiser contraintes dans session state
if "constraints" not in st.session_state:
    st.session_state.constraints = PlanningConstraints()

constraints = st.session_state.constraints

# ===== SECTION 1: GROUPES COHÃ‰SIFS (MUST BE TOGETHER) =====
st.markdown("## ğŸ‘« Groupes CohÃ©sifs (Toujours Ensemble)")
st.info("""
**Exemples** : Couples, Ã©quipes, binÃ´mes
**Comportement** : Les membres seront TOUJOURS Ã  la mÃªme table dans chaque session.
""")

with st.expander("â• Ajouter Groupe CohÃ©sif", expanded=False):
    with st.form("add_cohesive_group"):
        group_name = st.text_input("Nom du groupe", placeholder="Ex: Couple 1")

        # SÃ©lection participants
        available_participants = participants_df[["id", "nom", "prenom"]].copy()
        available_participants["label"] = (
            available_participants["id"].astype(str)
            + " - "
            + available_participants["prenom"].fillna("")
            + " "
            + available_participants["nom"]
        )

        selected = st.multiselect(
            "Participants (minimum 2)",
            options=available_participants["id"].tolist(),
            format_func=lambda x: available_participants[
                available_participants["id"] == x
            ]["label"].iloc[0],
        )

        submitted = st.form_submit_button("âœ… Ajouter Groupe")

        if submitted:
            if not group_name:
                st.error("âŒ Nom du groupe requis")
            elif len(selected) < 2:
                st.error("âŒ SÃ©lectionnez au moins 2 participants")
            else:
                # CrÃ©er contrainte
                new_group = GroupConstraint(
                    name=group_name,
                    constraint_type=GroupConstraintType.MUST_BE_TOGETHER,
                    participant_ids=set(selected),
                )
                constraints.cohesive_groups.append(new_group)
                st.session_state.constraints = constraints
                st.success(f"âœ… Groupe '{group_name}' ajoutÃ©")
                st.rerun()

# Afficher groupes cohÃ©sifs existants
if constraints.cohesive_groups:
    st.markdown("### ğŸ“‹ Groupes CohÃ©sifs DÃ©finis")
    for idx, group in enumerate(constraints.cohesive_groups):
        with st.expander(f"{group.name} ({len(group.participant_ids)} participants)"):
            # Liste participants
            for pid in group.participant_ids:
                p = participants_df[participants_df["id"] == pid].iloc[0]
                st.write(f"- {pid}: {p['prenom']} {p['nom']}")

            # Bouton suppression
            if st.button(f"ğŸ—‘ï¸ Supprimer '{group.name}'", key=f"del_cohesive_{idx}"):
                constraints.cohesive_groups.pop(idx)
                st.session_state.constraints = constraints
                st.rerun()
else:
    st.info("â„¹ï¸ Aucun groupe cohÃ©sif dÃ©fini")

st.divider()

# ===== SECTION 2: GROUPES EXCLUSIFS (MUST BE SEPARATE) =====
st.markdown("## ğŸš« Groupes Exclusifs (Toujours SÃ©parÃ©s)")
st.info("""
**Exemples** : Concurrents, ex-conjoints, incompatibilitÃ©s
**Comportement** : Les membres ne seront JAMAIS Ã  la mÃªme table.
""")

with st.expander("â• Ajouter Groupe Exclusif", expanded=False):
    with st.form("add_exclusive_group"):
        group_name_ex = st.text_input("Nom du groupe", placeholder="Ex: Concurrents A-B")

        selected_ex = st.multiselect(
            "Participants Ã  sÃ©parer (minimum 2)",
            options=available_participants["id"].tolist(),
            format_func=lambda x: available_participants[
                available_participants["id"] == x
            ]["label"].iloc[0],
            key="exclusive_multiselect",
        )

        submitted_ex = st.form_submit_button("âœ… Ajouter Groupe")

        if submitted_ex:
            if not group_name_ex:
                st.error("âŒ Nom du groupe requis")
            elif len(selected_ex) < 2:
                st.error("âŒ SÃ©lectionnez au moins 2 participants")
            else:
                new_group_ex = GroupConstraint(
                    name=group_name_ex,
                    constraint_type=GroupConstraintType.MUST_BE_SEPARATE,
                    participant_ids=set(selected_ex),
                )
                constraints.exclusive_groups.append(new_group_ex)
                st.session_state.constraints = constraints
                st.success(f"âœ… Groupe '{group_name_ex}' ajoutÃ©")
                st.rerun()

# Afficher groupes exclusifs existants
if constraints.exclusive_groups:
    st.markdown("### ğŸ“‹ Groupes Exclusifs DÃ©finis")
    for idx, group in enumerate(constraints.exclusive_groups):
        with st.expander(f"{group.name} ({len(group.participant_ids)} participants)"):
            for pid in group.participant_ids:
                p = participants_df[participants_df["id"] == pid].iloc[0]
                st.write(f"- {pid}: {p['prenom']} {p['nom']}")

            if st.button(f"ğŸ—‘ï¸ Supprimer '{group.name}'", key=f"del_exclusive_{idx}"):
                constraints.exclusive_groups.pop(idx)
                st.session_state.constraints = constraints
                st.rerun()
else:
    st.info("â„¹ï¸ Aucun groupe exclusif dÃ©fini")

st.divider()

# ===== SECTION 3: VALIDATION =====
st.markdown("## âœ… Validation Contraintes")

if "config" in st.session_state and st.session_state.config:
    config = st.session_state.config
    errors = constraints.validate(config)

    if errors:
        st.error(f"âŒ {len(errors)} erreur(s) dÃ©tectÃ©e(s)")
        for err in errors:
            st.warning(err)
    else:
        st.success("âœ… Toutes les contraintes sont valides !")
else:
    st.info("â„¹ï¸ Configurez d'abord votre Ã©vÃ©nement (page âš™ï¸ Configuration)")
```

---

## Tasks

### Backend
- [ ] Ajouter `GroupConstraintType`, `GroupConstraint`, `PlanningConstraints` Ã  `src/models.py`
- [ ] Modifier `src/baseline.py` :
  - `generate_baseline()` accepte paramÃ¨tre `constraints`
  - `_create_super_participants()` pour groupes cohÃ©sifs
  - `_assign_tables_with_constraints()` pour groupes exclusifs
  - `_violates_exclusive_constraint()` vÃ©rification
- [ ] Modifier `src/improvement.py` :
  - `improve_planning()` accepte paramÃ¨tre `constraints`
  - `_swap_violates_constraints()` protection swaps
- [ ] Modifier `src/planner.py` :
  - `generate_optimized_planning()` accepte `constraints`
  - Passer contraintes Ã  baseline et optimizer
- [ ] Tests unitaires `tests/test_constraints.py` :
  - Validation contraintes
  - Baseline respecte cohÃ©sifs
  - Baseline respecte exclusifs
  - Optimizer protÃ¨ge contraintes
  - DÃ©tection conflits

### Frontend
- [ ] CrÃ©er `app/pages/6_ğŸ”—_Contraintes.py`
  - Section groupes cohÃ©sifs
  - Section groupes exclusifs
  - Validation temps rÃ©el
  - Preview participants par groupe
- [ ] Modifier `app/pages/3_ğŸ¯_GÃ©nÃ©ration.py`
  - Passer `constraints` Ã  `generate_optimized_planning()`
  - Afficher contraintes actives

### Documentation
- [ ] Mettre Ã  jour `app/README.md` avec section contraintes
- [ ] CrÃ©er exemple CSV avec colonnes `groupe`
- [ ] Screenshots workflow contraintes

### Tests Manuels
- [ ] CrÃ©er groupe cohÃ©sif (couple) â†’ vÃ©rifier toujours ensemble
- [ ] CrÃ©er groupe exclusif (concurrents) â†’ vÃ©rifier jamais ensemble
- [ ] Tester conflit : groupe cohÃ©sif > capacitÃ© table
- [ ] Tester conflit : participant dans 2 groupes cohÃ©sifs
- [ ] VÃ©rifier optimizer ne casse pas contraintes (100 itÃ©rations)

---

## Definition of Done

- [ ] ModÃ¨le de donnÃ©es contraintes implÃ©mentÃ©
- [ ] Baseline gÃ©nÃ¨re planning respectant contraintes hard
- [ ] Optimizer protÃ¨ge contraintes (jamais violÃ©es)
- [ ] Interface Streamlit pour dÃ©finir groupes
- [ ] Tests unitaires passent (contraintes validÃ©es)
- [ ] Tests manuels validÃ©s (workflow complet)
- [ ] Documentation mise Ã  jour

---

## Completion Notes

*(Ã€ remplir aprÃ¨s implÃ©mentation)*

---

## Change Log

| Date | Author | Change |
|------|--------|--------|
| 2026-01-12 | James | Story crÃ©Ã©e (must be together + must be separate) |
