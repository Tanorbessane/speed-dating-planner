# Story 4.4 - PrioritÃ©s VIP

**Epic** : Epic 4 - Gestion Ã‰vÃ©nements RÃ©els
**Status** : IN PROGRESS
**Priority** : MEDIUM
**Effort** : 2 jours
**Created** : 2026-01-12

---

## ğŸ“‹ User Story

**En tant qu'** organisateur d'Ã©vÃ©nement networking/speed dating,
**Je veux** marquer certains participants comme VIP (speakers, sponsors, invitÃ©s spÃ©ciaux),
**Afin que** ces VIP rencontrent le maximum de personnes diffÃ©rentes et reÃ§oivent un traitement prioritaire dans l'algorithme d'Ã©quitÃ©.

---

## ğŸ¯ Business Value

**Contexte** :
- Ã‰vÃ©nements rÃ©els ont souvent des **invitÃ©s VIP** (speakers, sponsors, personnalitÃ©s)
- Ces VIP doivent avoir une **expÃ©rience optimale** : rencontrer le maximum de personnes
- Les organisateurs veulent **prioriser l'Ã©quitÃ© pour les VIP** par rapport aux participants rÃ©guliers

**Impact** :
- âœ… ExpÃ©rience VIP optimisÃ©e â†’ satisfaction sponsors/speakers
- âœ… MÃ©triques sÃ©parÃ©es â†’ reporting diffÃ©renciÃ© VIP vs public
- âœ… FlexibilitÃ© organisateurs â†’ adaptation aux besoins Ã©vÃ©nements rÃ©els

---

## âœ… Acceptance Criteria

### AC1 : ModÃ¨le de donnÃ©es Ã©tendu
- [ ] `Participant` a un champ `is_vip: bool` (dÃ©faut: False)
- [ ] Import CSV supporte colonne optionnelle `vip` (valeurs: "true", "false", "1", "0", "yes", "no")
- [ ] Validation : `is_vip` doit Ãªtre boolÃ©en

### AC2 : Interface de gestion VIP
- [ ] Page **ğŸ‘¥ Participants** permet de voir statut VIP
- [ ] Indicateur visuel (ğŸŒŸ ou badge) pour VIP dans tableau
- [ ] Bouton "Marquer comme VIP" / "Retirer VIP" pour chaque participant
- [ ] Compteur : "X VIP / N participants"

### AC3 : Algorithme d'Ã©quitÃ© adaptÃ©
- [ ] Dans `enforce_equity()` : VIP traitÃ©s en prioritÃ©
- [ ] Si equity_gap > 1 : prioritÃ© swaps bÃ©nÃ©fiques pour VIP
- [ ] Under-exposed VIP reÃ§oivent swaps avant under-exposed rÃ©guliers
- [ ] Over-exposed rÃ©guliers swappÃ©s en prioritÃ© avec VIP under-exposed

### AC4 : MÃ©triques VIP sÃ©parÃ©es
- [ ] `PlanningMetrics` a un champ optionnel `vip_metrics: Optional[VIPMetrics]`
- [ ] `VIPMetrics` contient :
  - `vip_count: int` (nombre de VIP)
  - `vip_min_unique: int` (min rencontres uniques VIP)
  - `vip_max_unique: int` (max rencontres uniques VIP)
  - `vip_mean_unique: float` (moyenne rencontres VIP)
  - `vip_equity_gap: int` (equity gap VIP seulement)
  - `non_vip_min_unique: int`
  - `non_vip_max_unique: int`
  - `non_vip_mean_unique: float`
  - `non_vip_equity_gap: int`
- [ ] `compute_metrics()` calcule mÃ©triques VIP si participants VIP prÃ©sents

### AC5 : Affichage diffÃ©renciÃ©
- [ ] Dashboard affiche mÃ©triques sÃ©parÃ©es VIP vs non-VIP
- [ ] Section "ğŸ“Š MÃ©triques VIP" avec :
  - Nombre de VIP
  - Min/Max/Moyenne rencontres VIP
  - Equity gap VIP
- [ ] Section "ğŸ‘¥ MÃ©triques Participants RÃ©guliers"
- [ ] Comparaison visuelle (2 colonnes ou graphes cÃ´te-Ã -cÃ´te)

### AC6 : Export inclut statut VIP
- [ ] CSV export a colonne `is_vip` (true/false)
- [ ] JSON export a champ `"is_vip": true/false` par participant
- [ ] PDF export (futur) affiche badge VIP

---

## ğŸ—ï¸ Technical Design

### 1. Modification ModÃ¨le de DonnÃ©es

**Fichier** : `src/models.py`

```python
@dataclass
class Participant:
    """ReprÃ©sente un participant Ã  l'Ã©vÃ©nement."""
    id: int
    nom: str
    prenom: Optional[str] = None
    email: Optional[str] = None
    groupe: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    is_vip: bool = False  # NOUVEAU

    def __post_init__(self) -> None:
        # Validation existante
        if not isinstance(self.is_vip, bool):
            raise ValueError(f"is_vip doit Ãªtre un boolÃ©en, reÃ§u: {self.is_vip}")


@dataclass
class VIPMetrics:
    """MÃ©triques sÃ©parÃ©es pour participants VIP et rÃ©guliers."""
    vip_count: int
    vip_min_unique: int
    vip_max_unique: int
    vip_mean_unique: float
    vip_equity_gap: int

    non_vip_count: int
    non_vip_min_unique: int
    non_vip_max_unique: int
    non_vip_mean_unique: float
    non_vip_equity_gap: int


@dataclass
class PlanningMetrics:
    """MÃ©triques de qualitÃ© d'un planning."""
    total_unique_pairs: int
    total_repeat_pairs: int
    unique_meetings_per_person: List[int]
    min_unique: int
    max_unique: int
    mean_unique: float
    vip_metrics: Optional[VIPMetrics] = None  # NOUVEAU
```

### 2. Calcul MÃ©triques VIP

**Fichier** : `src/metrics.py`

```python
def compute_metrics(
    planning: Planning, config: PlanningConfig, participants: Optional[List[Participant]] = None
) -> PlanningMetrics:
    """Calcule mÃ©triques avec support VIP."""

    # Calculs existants...

    # Si participants fournis, calculer mÃ©triques VIP
    vip_metrics = None
    if participants:
        vip_metrics = _compute_vip_metrics(unique_meetings_per_person, participants)

    return PlanningMetrics(
        total_unique_pairs=total_unique_pairs,
        total_repeat_pairs=total_repeat_pairs,
        unique_meetings_per_person=unique_meetings_per_person,
        min_unique=min_unique,
        max_unique=max_unique,
        mean_unique=mean_unique,
        vip_metrics=vip_metrics,
    )


def _compute_vip_metrics(
    unique_meetings_per_person: List[int], participants: List[Participant]
) -> Optional[VIPMetrics]:
    """Calcule mÃ©triques sÃ©parÃ©es VIP vs non-VIP."""

    vip_participants = [p for p in participants if p.is_vip]
    non_vip_participants = [p for p in participants if not p.is_vip]

    if not vip_participants:
        return None  # Pas de VIP â†’ pas de mÃ©triques sÃ©parÃ©es

    # MÃ©triques VIP
    vip_meetings = [unique_meetings_per_person[p.id] for p in vip_participants]
    vip_min = min(vip_meetings)
    vip_max = max(vip_meetings)
    vip_mean = sum(vip_meetings) / len(vip_meetings)
    vip_equity_gap = vip_max - vip_min

    # MÃ©triques non-VIP
    if non_vip_participants:
        non_vip_meetings = [unique_meetings_per_person[p.id] for p in non_vip_participants]
        non_vip_min = min(non_vip_meetings)
        non_vip_max = max(non_vip_meetings)
        non_vip_mean = sum(non_vip_meetings) / len(non_vip_meetings)
        non_vip_equity_gap = non_vip_max - non_vip_min
    else:
        # Tous sont VIP
        non_vip_min = non_vip_max = 0
        non_vip_mean = 0.0
        non_vip_equity_gap = 0

    return VIPMetrics(
        vip_count=len(vip_participants),
        vip_min_unique=vip_min,
        vip_max_unique=vip_max,
        vip_mean_unique=vip_mean,
        vip_equity_gap=vip_equity_gap,
        non_vip_count=len(non_vip_participants),
        non_vip_min_unique=non_vip_min,
        non_vip_max_unique=non_vip_max,
        non_vip_mean_unique=non_vip_mean,
        non_vip_equity_gap=non_vip_equity_gap,
    )
```

### 3. Adaptation Algorithme Equity

**Fichier** : `src/equity.py`

```python
def enforce_equity(
    planning: Planning,
    config: PlanningConfig,
    constraints: Optional[PlanningConstraints] = None,
    participants: Optional[List[Participant]] = None,  # NOUVEAU
) -> Planning:
    """Garantit equity_gap â‰¤ 1 avec prioritÃ© VIP."""

    # ... code existant ...

    # Identifier over-exposed et under-exposed
    over_exposed = _find_over_exposed(metrics)
    under_exposed = _find_under_exposed(metrics)

    # NOUVEAU : Si participants VIP, prioriser swaps VIP
    if participants:
        vip_ids = {p.id for p in participants if p.is_vip}

        # SÃ©parer VIP et non-VIP
        over_vip = [p for p in over_exposed if p in vip_ids]
        over_regular = [p for p in over_exposed if p not in vip_ids]
        under_vip = [p for p in under_exposed if p in vip_ids]
        under_regular = [p for p in under_exposed if p not in vip_ids]

        # Ordre de prioritÃ© pour swaps :
        # 1. Under-exposed VIP avec over-exposed rÃ©guliers (prioritÃ© max)
        # 2. Under-exposed VIP avec over-exposed VIP
        # 3. Under-exposed rÃ©guliers avec over-exposed
        swap_priorities = [
            (under_vip, over_regular),   # PrioritÃ© 1
            (under_vip, over_vip),       # PrioritÃ© 2
            (under_regular, over_exposed), # PrioritÃ© 3
        ]
    else:
        # Pas de VIP : comportement standard
        swap_priorities = [(under_exposed, over_exposed)]

    # Chercher swaps bÃ©nÃ©fiques avec prioritÃ©s
    swap_found = False
    for under_list, over_list in swap_priorities:
        for p_under in under_list:
            for p_over in over_list:
                if _try_swap_participants(
                    equitable, p_over, p_under, met_pairs, config, constraints
                ):
                    swap_found = True
                    break
            if swap_found:
                break
        if swap_found:
            break

    # ... reste du code ...
```

### 4. Interface Streamlit VIP

**Fichier** : `app/pages/5_ğŸ‘¥_Participants.py`

Ajouter section "ğŸŒŸ Gestion VIP" :

```python
# AprÃ¨s l'affichage du tableau de participants

st.divider()
st.markdown("### ğŸŒŸ Gestion VIP")

if "participants" in st.session_state and st.session_state.participants is not None:
    participants_df = st.session_state.participants

    # Compteur VIP
    vip_count = participants_df["is_vip"].sum() if "is_vip" in participants_df.columns else 0
    col1, col2 = st.columns(2)
    with col1:
        st.metric("ğŸ‘¥ Total Participants", len(participants_df))
    with col2:
        st.metric("ğŸŒŸ VIP", vip_count)

    # SÃ©lection pour marquer/dÃ©marquer VIP
    st.markdown("**Marquer/Retirer statut VIP**")

    # CrÃ©er liste affichable
    participant_options = [
        f"{row['id']}: {row.get('prenom', '')} {row['nom']} {'ğŸŒŸ' if row.get('is_vip', False) else ''}"
        for _, row in participants_df.iterrows()
    ]

    selected_participants = st.multiselect(
        "SÃ©lectionner participants",
        options=range(len(participants_df)),
        format_func=lambda i: participant_options[i],
    )

    col1, col2 = st.columns(2)
    with col1:
        if st.button("ğŸŒŸ Marquer comme VIP", use_container_width=True):
            for idx in selected_participants:
                st.session_state.participants.at[idx, "is_vip"] = True
            st.success(f"âœ… {len(selected_participants)} participant(s) marquÃ©(s) VIP")
            st.rerun()

    with col2:
        if st.button("âŒ Retirer VIP", use_container_width=True):
            for idx in selected_participants:
                st.session_state.participants.at[idx, "is_vip"] = False
            st.success(f"âœ… {len(selected_participants)} participant(s) retirÃ©s de VIP")
            st.rerun()
```

---

## ğŸ“Š Affichage Dashboard

**Fichier** : `app/pages/1_ğŸ“Š_Dashboard.py` ou `app/pages/4_ğŸ“ˆ_RÃ©sultats.py`

```python
# Si mÃ©triques VIP disponibles
if metrics.vip_metrics:
    st.divider()
    st.markdown("### ğŸ“Š MÃ©triques VIP vs RÃ©guliers")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("#### ğŸŒŸ VIP")
        st.metric("Nombre", metrics.vip_metrics.vip_count)
        st.metric("Min rencontres", metrics.vip_metrics.vip_min_unique)
        st.metric("Max rencontres", metrics.vip_metrics.vip_max_unique)
        st.metric("Moyenne", f"{metrics.vip_metrics.vip_mean_unique:.1f}")
        if metrics.vip_metrics.vip_equity_gap <= 1:
            st.metric("Equity Gap", metrics.vip_metrics.vip_equity_gap, delta="âœ…")
        else:
            st.metric("Equity Gap", metrics.vip_metrics.vip_equity_gap, delta="âš ï¸")

    with col2:
        st.markdown("#### ğŸ‘¥ Participants RÃ©guliers")
        st.metric("Nombre", metrics.vip_metrics.non_vip_count)
        st.metric("Min rencontres", metrics.vip_metrics.non_vip_min_unique)
        st.metric("Max rencontres", metrics.vip_metrics.non_vip_max_unique)
        st.metric("Moyenne", f"{metrics.vip_metrics.non_vip_mean_unique:.1f}")
        if metrics.vip_metrics.non_vip_equity_gap <= 1:
            st.metric("Equity Gap", metrics.vip_metrics.non_vip_equity_gap, delta="âœ…")
        else:
            st.metric("Equity Gap", metrics.vip_metrics.non_vip_equity_gap, delta="âš ï¸")
```

---

## ğŸ§ª Tests

**Fichier** : `tests/test_vip.py`

Tests Ã  crÃ©er :
1. âœ… `test_participant_vip_field()` : CrÃ©ation participant avec is_vip
2. âœ… `test_vip_metrics_calculation()` : Calcul mÃ©triques VIP sÃ©parÃ©es
3. âœ… `test_vip_priority_in_equity()` : VIP under-exposed reÃ§oivent prioritÃ©
4. âœ… `test_vip_export_csv()` : Export CSV inclut colonne is_vip
5. âœ… `test_vip_import_csv()` : Import CSV avec colonne vip
6. âœ… `test_no_vip_metrics_when_no_vip()` : Pas de mÃ©triques VIP si aucun VIP

---

## ğŸ“ Files to Create/Modify

### CrÃ©er
- `tests/test_vip.py` : Tests unitaires VIP

### Modifier
- `src/models.py` : Ajouter `is_vip` + `VIPMetrics`
- `src/metrics.py` : Calculer mÃ©triques VIP
- `src/equity.py` : Prioriser VIP dans swaps
- `src/planner.py` : Passer `participants` Ã  equity
- `src/participants.py` : Parser colonne `vip` dans CSV
- `app/pages/5_ğŸ‘¥_Participants.py` : Interface gestion VIP
- `app/pages/3_ğŸ¯_GÃ©nÃ©ration.py` : Passer participants au planner
- `app/pages/4_ğŸ“ˆ_RÃ©sultats.py` : Afficher mÃ©triques VIP

---

## âš ï¸ Limitations & ConsidÃ©rations

### Limitations
- VIP reÃ§oivent **prioritÃ©** mais pas **garantie absolue** (contraintes hard peuvent limiter)
- Si tous participants sont VIP â†’ comportement identique au standard
- Equity gap global peut Ãªtre > 1 mÃªme si VIP equity gap â‰¤ 1 (trade-off acceptÃ©)

### ConsidÃ©rations futures
- **Story future** : Poids VIP (VIP poids 2Ã— dans scoring)
- **Story future** : Multiple niveaux VIP (Gold, Silver, Bronze)
- **Story future** : Contrainte "VIP ne doivent pas se rencontrer entre eux" (maximiser exposition public)

---

## âœ… Definition of Done

- [ ] ModÃ¨le `Participant` a champ `is_vip`
- [ ] Import CSV supporte colonne `vip`
- [ ] Interface Streamlit permet de marquer/retirer VIP
- [ ] Algorithme equity priorise VIP under-exposed
- [ ] MÃ©triques VIP calculÃ©es et affichÃ©es sÃ©parÃ©ment
- [ ] Export CSV/JSON inclut statut VIP
- [ ] Tests unitaires passent (6+ tests)
- [ ] Documentation mise Ã  jour
- [ ] Test manuel : planning avec 3 VIP / 20 participants â†’ VIP equity_gap â‰¤ 1

---

## ğŸš€ Ready to Implement

Story 4.4 est prÃªte Ã  Ãªtre implÃ©mentÃ©e !

**Ordre d'implÃ©mentation recommandÃ©** :
1. ModÃ¨les de donnÃ©es (models.py)
2. Calcul mÃ©triques VIP (metrics.py)
3. Adaptation equity (equity.py)
4. Interface Streamlit (pages/)
5. Tests unitaires
6. Test manuel E2E
