# Story 5.2 : Heatmap Matrice Rencontres N√óN

**Epic**: Epic 5 - Dashboards & Visualisation
**Priorit√©**: HAUTE
**Estimation**: 3 points
**Status**: In Progress

## Contexte

Les organisateurs d'√©v√©nements ont besoin de **visualiser rapidement** qui a rencontr√© qui, combien de fois, et identifier les r√©p√©titions. Une **heatmap** (carte de chaleur) N√óN permet de voir d'un coup d'≈ìil :
- Quelles paires se sont rencontr√©es (et combien de fois)
- Les r√©p√©titions (cellules rouges fonc√©es)
- Les participants qui ne se sont jamais rencontr√©s (cellules blanches)

## Objectif

Cr√©er une **heatmap interactive** (matrice N√óN) affichant le nombre de rencontres entre chaque paire de participants, avec :
- **Interactivit√©** : hover tooltips avec noms et nombre de rencontres
- **√âchelle de couleur intuitive** : blanc (0) ‚Üí rouge fonc√© (max r√©p√©titions)
- **Noms participants** sur axes (si liste participants charg√©e)
- **Int√©gration** dans page R√©sultats (nouvel onglet "üó∫Ô∏è Heatmap")

## User Story

**En tant qu'** organisateur d'√©v√©nement
**Je veux** visualiser une heatmap des rencontres entre participants
**Afin de** identifier rapidement les r√©p√©titions et v√©rifier que le planning maximise les rencontres uniques

## Acceptance Criteria

### AC1: Matrice N√óN avec Nombre Rencontres
- [ ] Matrice carr√©e N√óN (N = nombre de participants)
- [ ] Cellule (i, j) = nombre de rencontres entre participant i et participant j
- [ ] Diagonale = 0 (un participant ne se rencontre pas lui-m√™me)
- [ ] Matrice sym√©trique : cellule (i, j) = cellule (j, i)

### AC2: √âchelle de Couleur Intuitive
- [ ] Colormap : blanc (0 rencontres) ‚Üí jaune (1) ‚Üí orange (2) ‚Üí rouge fonc√© (3+)
- [ ] L√©gende colormap affich√©e clairement
- [ ] Contraste suffisant pour distinguer 0, 1, 2, 3+ rencontres

### AC3: Interactivit√© Hover Tooltips
- [ ] Hover sur cellule (i, j) affiche tooltip avec :
  - Nom participant i
  - Nom participant j
  - Nombre de rencontres
  - Exemple : "Jean Dupont ‚Üî Marie Martin : 2 rencontres"
- [ ] Tooltip fonctionne avec ou sans noms participants (fallback IDs)

### AC4: Axes avec Noms Participants
- [ ] Axe X : noms participants (ou IDs si pas de liste)
- [ ] Axe Y : noms participants (ou IDs si pas de liste)
- [ ] Rotation labels axe X si n√©cessaire (lisibilit√©)
- [ ] Taille police adapt√©e √† N (plus petit si N > 50)

### AC5: Int√©gration Page R√©sultats
- [ ] Nouvel onglet "üó∫Ô∏è Heatmap" dans page R√©sultats
- [ ] Heatmap affich√©e apr√®s onglet "üìä M√©triques"
- [ ] Titre clair : "Matrice des Rencontres"
- [ ] Info bulle expliquant comment lire la heatmap

### AC6: Performance et Scaling
- [ ] Heatmap fluide pour N ‚â§ 100 participants
- [ ] Warning si N > 100 : "Heatmap peut √™tre lente pour grands plannings"
- [ ] Option "Afficher Heatmap" (bouton) pour N > 50 (√©viter render automatique)

### AC7: Statistiques Associ√©es
- [ ] Afficher sous heatmap :
  - Total paires rencontr√©es : X / (N√ó(N-1)/2)
  - Taux couverture : X%
  - R√©p√©titions (‚â•2) : Y paires
  - Max rencontres entre une paire : Z

## Design Technique

### 1. Fonction Calcul Matrice (src/analysis.py - nouveau fichier)

```python
import numpy as np
from typing import Tuple
from src.models import Planning

def compute_meetings_matrix(planning: Planning, N: int) -> np.ndarray:
    """Calcule matrice N√óN des rencontres entre participants.

    Args:
        planning: Planning √† analyser
        N: Nombre total de participants

    Returns:
        Matrice numpy N√óN o√π matrix[i][j] = nombre rencontres entre i et j

    Example:
        >>> matrix = compute_meetings_matrix(planning, config.N)
        >>> matrix[0][5]  # Nombre rencontres entre participant 0 et 5
        2
        >>> matrix[5][0]  # Sym√©trique
        2

    Complexity:
        Time: O(S √ó X √ó x¬≤) o√π S=sessions, X=tables, x=places/table
        Space: O(N¬≤)
    """
    # Initialiser matrice N√óN √† z√©ro
    matrix = np.zeros((N, N), dtype=int)

    # Pour chaque session et chaque table
    for session in planning.sessions:
        for table in session.tables:
            participants = list(table)
            # Pour chaque paire dans la table
            for i in range(len(participants)):
                for j in range(i + 1, len(participants)):
                    p1, p2 = participants[i], participants[j]
                    # Incr√©menter compteur pour cette paire (sym√©trique)
                    matrix[p1][p2] += 1
                    matrix[p2][p1] += 1

    return matrix


def compute_matrix_statistics(matrix: np.ndarray) -> dict:
    """Calcule statistiques sur matrice rencontres.

    Args:
        matrix: Matrice N√óN rencontres

    Returns:
        Dict avec statistiques :
        - total_pairs_met: Nombre paires s'√©tant rencontr√©es ‚â•1 fois
        - total_possible_pairs: N√ó(N-1)/2
        - coverage_rate: Pourcentage paires rencontr√©es
        - repeat_pairs: Nombre paires rencontr√©es ‚â•2 fois
        - max_meetings: Maximum rencontres entre une paire

    Example:
        >>> stats = compute_matrix_statistics(matrix)
        >>> stats['coverage_rate']
        87.5  # 87.5% des paires se sont rencontr√©es
    """
    N = matrix.shape[0]

    # Total paires possibles : N√ó(N-1)/2
    total_possible_pairs = N * (N - 1) // 2

    # Compter paires rencontr√©es (>= 1)
    # Ne compter que triangle sup√©rieur (matrice sym√©trique)
    pairs_met = 0
    repeat_pairs = 0
    max_meetings = 0

    for i in range(N):
        for j in range(i + 1, N):
            meetings = matrix[i][j]
            if meetings >= 1:
                pairs_met += 1
            if meetings >= 2:
                repeat_pairs += 1
            max_meetings = max(max_meetings, meetings)

    coverage_rate = (
        100 * pairs_met / total_possible_pairs if total_possible_pairs > 0 else 0
    )

    return {
        "total_pairs_met": pairs_met,
        "total_possible_pairs": total_possible_pairs,
        "coverage_rate": coverage_rate,
        "repeat_pairs": repeat_pairs,
        "max_meetings": max_meetings,
    }
```

### 2. Fonction Render Heatmap (src/visualizations.py - nouveau fichier)

```python
import plotly.graph_objects as go
import pandas as pd
from typing import Optional

def create_meetings_heatmap(
    matrix: np.ndarray,
    participants_df: Optional[pd.DataFrame] = None,
    title: str = "Matrice des Rencontres entre Participants"
) -> go.Figure:
    """Cr√©e heatmap interactive Plotly pour matrice rencontres.

    Args:
        matrix: Matrice N√óN rencontres
        participants_df: DataFrame participants pour noms (optionnel)
        title: Titre du graphique

    Returns:
        Figure Plotly interactive

    Example:
        >>> fig = create_meetings_heatmap(matrix, participants_df)
        >>> st.plotly_chart(fig, use_container_width=True)
    """
    N = matrix.shape[0]

    # Construire labels axes (noms ou IDs)
    if participants_df is not None and not participants_df.empty:
        labels = []
        for i in range(N):
            participant = participants_df[participants_df["id"] == i]
            if not participant.empty:
                row = participant.iloc[0]
                prenom = row.get("prenom", "")
                nom = row.get("nom", "")
                if pd.notna(prenom) and prenom:
                    labels.append(f"{prenom} {nom}")
                else:
                    labels.append(str(nom))
            else:
                labels.append(f"P{i}")
    else:
        labels = [f"P{i}" for i in range(N)]

    # Construire texte hover personnalis√©
    hover_text = []
    for i in range(N):
        row_hover = []
        for j in range(N):
            if i == j:
                text = f"{labels[i]}<br>(soi-m√™me)"
            else:
                meetings = matrix[i][j]
                text = f"{labels[i]} ‚Üî {labels[j]}<br><b>{meetings} rencontre(s)</b>"
            row_hover.append(text)
        hover_text.append(row_hover)

    # Cr√©er heatmap Plotly
    fig = go.Figure(data=go.Heatmap(
        z=matrix,
        x=labels,
        y=labels,
        text=hover_text,
        hovertemplate='%{text}<extra></extra>',
        colorscale=[
            [0.0, 'white'],       # 0 rencontres
            [0.33, 'yellow'],     # 1 rencontre
            [0.66, 'orange'],     # 2 rencontres
            [1.0, 'darkred']      # 3+ rencontres
        ],
        colorbar=dict(
            title="Rencontres",
            tickmode='linear',
            tick0=0,
            dtick=1
        ),
        showscale=True
    ))

    # Layout
    fig.update_layout(
        title=title,
        xaxis_title="Participants",
        yaxis_title="Participants",
        width=800,
        height=800,
        xaxis=dict(side='bottom'),
        yaxis=dict(autorange='reversed')  # Y de haut en bas
    )

    # Rotation labels X si N > 20
    if N > 20:
        fig.update_xaxes(tickangle=45)

    return fig
```

### 3. Int√©gration Page R√©sultats

Ajouter nouvel onglet dans `app/pages/4_üìà_R√©sultats.py` :

```python
# Onglets
tab1, tab2, tab3, tab4 = st.tabs([
    "üìä M√©triques",
    "üó∫Ô∏è Heatmap",      # NOUVEAU
    "üíæ Exports",
    "üîç Analyses Avanc√©es"
])

# ===== TAB 2: HEATMAP =====
with tab2:
    st.markdown("### üó∫Ô∏è Matrice des Rencontres")

    st.info("""
    **Comment lire cette heatmap** :
    - Chaque cellule (i, j) indique combien de fois le participant i a rencontr√© le participant j
    - **Blanc** : 0 rencontre (ne se sont jamais rencontr√©s)
    - **Jaune** : 1 rencontre (optimal !)
    - **Orange** : 2 rencontres (r√©p√©tition)
    - **Rouge fonc√©** : 3+ rencontres (r√©p√©titions multiples)
    """)

    # Warning si N > 100
    if config.N > 100:
        st.warning("‚ö†Ô∏è Heatmap peut √™tre lente pour grands plannings (N > 100)")

    # Bouton afficher si N > 50
    show_heatmap = True
    if config.N > 50:
        show_heatmap = st.button("üó∫Ô∏è Afficher Heatmap", use_container_width=True)

    if show_heatmap:
        from src.analysis import compute_meetings_matrix, compute_matrix_statistics
        from src.visualizations import create_meetings_heatmap

        # Calculer matrice
        with st.spinner("Calcul matrice rencontres..."):
            matrix = compute_meetings_matrix(planning, config.N)

        # Afficher heatmap
        participants_df = st.session_state.get("participants", None)
        fig = create_meetings_heatmap(matrix, participants_df)
        st.plotly_chart(fig, use_container_width=True)

        # Statistiques
        stats = compute_matrix_statistics(matrix)

        st.divider()
        st.markdown("### üìä Statistiques Matrice")

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric(
                "Paires rencontr√©es",
                f"{stats['total_pairs_met']}/{stats['total_possible_pairs']}"
            )

        with col2:
            st.metric("Taux couverture", f"{stats['coverage_rate']:.1f}%")

        with col3:
            st.metric("R√©p√©titions (‚â•2)", stats['repeat_pairs'])

        with col4:
            st.metric("Max rencontres paire", stats['max_meetings'])
```

## Tasks d'Impl√©mentation

- [ ] **Task 1**: Cr√©er `src/analysis.py` avec `compute_meetings_matrix()` et `compute_matrix_statistics()`
- [ ] **Task 2**: Cr√©er `src/visualizations.py` avec `create_meetings_heatmap()`
- [ ] **Task 3**: Modifier `app/pages/4_üìà_R√©sultats.py` pour ajouter onglet Heatmap
- [ ] **Task 4**: Tests unitaires pour `compute_meetings_matrix()`
- [ ] **Task 5**: Tests unitaires pour `compute_matrix_statistics()`
- [ ] **Task 6**: Tests manuels Streamlit (N=10, N=50, N=100)

## Testing

### Tests Unitaires (tests/test_analysis.py)

```python
def test_compute_meetings_matrix_simple():
    """Matrice simple 6 participants."""
    config = PlanningConfig(N=6, X=2, x=3, S=2)
    planning = generate_baseline(config, seed=42)

    matrix = compute_meetings_matrix(planning, config.N)

    # Matrice carr√©e N√óN
    assert matrix.shape == (6, 6)

    # Diagonale = 0 (personne ne se rencontre soi-m√™me)
    assert all(matrix[i][i] == 0 for i in range(6))

    # Sym√©trique
    for i in range(6):
        for j in range(6):
            assert matrix[i][j] == matrix[j][i]

def test_compute_matrix_statistics():
    """Statistiques matrice."""
    matrix = np.array([
        [0, 1, 2, 0],
        [1, 0, 1, 1],
        [2, 1, 0, 0],
        [0, 1, 0, 0]
    ])

    stats = compute_matrix_statistics(matrix)

    # Total paires : 4√ó3/2 = 6
    assert stats['total_possible_pairs'] == 6

    # Paires rencontr√©es : (0,1), (0,2), (1,2), (1,3) = 4
    assert stats['total_pairs_met'] == 4

    # R√©p√©titions (‚â•2) : (0,2) = 1
    assert stats['repeat_pairs'] == 1

    # Max : 2
    assert stats['max_meetings'] == 2
```

## Notes Techniques

### Librairies Requises
- **numpy** : calcul matriciel (d√©j√† pr√©sent)
- **plotly** : heatmap interactive (ajouter si absent)

### Performance
- Calcul matrice : O(S √ó X √ó x¬≤) ‚âà O(N √ó S) en pratique
- Render Plotly : fluide jusqu'√† N=100, acceptable jusqu'√† N=200

### Alternatives Consid√©r√©es
- **Seaborn heatmap** : statique, moins interactif
- **Matplotlib imshow** : statique, pas de hover tooltips
- **Plotly heatmap** : ‚úÖ choisi pour interactivit√©

## Crit√®res de Succ√®s

- ‚úÖ Heatmap interactive affich√©e dans page R√©sultats
- ‚úÖ √âchelle couleur intuitive (blanc ‚Üí rouge)
- ‚úÖ Hover tooltips avec noms et nombre rencontres
- ‚úÖ Statistiques matrice affich√©es
- ‚úÖ Performance acceptable (N ‚â§ 100)
- ‚úÖ Tests unitaires passent

## Temps Estim√©

- Impl√©mentation : 2h
- Tests : 1h
- **Total : 3h**
